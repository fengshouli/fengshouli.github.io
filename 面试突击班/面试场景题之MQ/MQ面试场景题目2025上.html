<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>RabbitMQ的消息处理模型 | 冯手力-java学习之路</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.49d708b7.css" as="style"><link rel="preload" href="/assets/js/app.e6553dd9.js" as="script"><link rel="preload" href="/assets/js/2.f327c6f6.js" as="script"><link rel="preload" href="/assets/js/1.65890b21.js" as="script"><link rel="preload" href="/assets/js/120.5d9edcac.js" as="script"><link rel="prefetch" href="/assets/js/10.28da0279.js"><link rel="prefetch" href="/assets/js/100.3f67ceba.js"><link rel="prefetch" href="/assets/js/101.1e6b498b.js"><link rel="prefetch" href="/assets/js/102.00199558.js"><link rel="prefetch" href="/assets/js/103.cb589f22.js"><link rel="prefetch" href="/assets/js/104.cab26ab3.js"><link rel="prefetch" href="/assets/js/105.bf01bd31.js"><link rel="prefetch" href="/assets/js/106.3896d2a8.js"><link rel="prefetch" href="/assets/js/107.940ed5bd.js"><link rel="prefetch" href="/assets/js/108.d0227db2.js"><link rel="prefetch" href="/assets/js/109.c4ea9421.js"><link rel="prefetch" href="/assets/js/11.499b1ef6.js"><link rel="prefetch" href="/assets/js/110.65523b02.js"><link rel="prefetch" href="/assets/js/111.4e289c06.js"><link rel="prefetch" href="/assets/js/112.37b56330.js"><link rel="prefetch" href="/assets/js/113.dee38bce.js"><link rel="prefetch" href="/assets/js/114.d54f016e.js"><link rel="prefetch" href="/assets/js/115.a5d342ba.js"><link rel="prefetch" href="/assets/js/116.61b42bbf.js"><link rel="prefetch" href="/assets/js/117.384fa39a.js"><link rel="prefetch" href="/assets/js/118.de70117e.js"><link rel="prefetch" href="/assets/js/119.301c1a9b.js"><link rel="prefetch" href="/assets/js/12.e2bb6bf6.js"><link rel="prefetch" href="/assets/js/121.1030f828.js"><link rel="prefetch" href="/assets/js/122.93206142.js"><link rel="prefetch" href="/assets/js/123.160b984e.js"><link rel="prefetch" href="/assets/js/124.41c4322e.js"><link rel="prefetch" href="/assets/js/125.841832fa.js"><link rel="prefetch" href="/assets/js/126.ec3ffa0f.js"><link rel="prefetch" href="/assets/js/127.b0a0a372.js"><link rel="prefetch" href="/assets/js/128.4f847758.js"><link rel="prefetch" href="/assets/js/129.4298badb.js"><link rel="prefetch" href="/assets/js/13.6e92c677.js"><link rel="prefetch" href="/assets/js/14.50fc1271.js"><link rel="prefetch" href="/assets/js/15.53f9b1a9.js"><link rel="prefetch" href="/assets/js/16.2288ae4a.js"><link rel="prefetch" href="/assets/js/17.a67122e3.js"><link rel="prefetch" href="/assets/js/18.b5b3b2b0.js"><link rel="prefetch" href="/assets/js/19.98e5962f.js"><link rel="prefetch" href="/assets/js/20.c3553c70.js"><link rel="prefetch" href="/assets/js/21.3d794f8a.js"><link rel="prefetch" href="/assets/js/22.5e27acdb.js"><link rel="prefetch" href="/assets/js/23.572115ce.js"><link rel="prefetch" href="/assets/js/24.fa6ad6bf.js"><link rel="prefetch" href="/assets/js/25.ebec8bf4.js"><link rel="prefetch" href="/assets/js/26.11811683.js"><link rel="prefetch" href="/assets/js/27.da58e60d.js"><link rel="prefetch" href="/assets/js/28.5113a04f.js"><link rel="prefetch" href="/assets/js/29.b55cc958.js"><link rel="prefetch" href="/assets/js/3.00f65edc.js"><link rel="prefetch" href="/assets/js/30.0762efaf.js"><link rel="prefetch" href="/assets/js/31.47e1502f.js"><link rel="prefetch" href="/assets/js/32.9b69bd31.js"><link rel="prefetch" href="/assets/js/33.21a56e2a.js"><link rel="prefetch" href="/assets/js/34.5a9ada4b.js"><link rel="prefetch" href="/assets/js/35.8791941c.js"><link rel="prefetch" href="/assets/js/36.604d27ff.js"><link rel="prefetch" href="/assets/js/37.658cf2d4.js"><link rel="prefetch" href="/assets/js/38.71d8fd9e.js"><link rel="prefetch" href="/assets/js/39.e55e40ac.js"><link rel="prefetch" href="/assets/js/4.0c95c87a.js"><link rel="prefetch" href="/assets/js/40.259535fd.js"><link rel="prefetch" href="/assets/js/41.d6e85839.js"><link rel="prefetch" href="/assets/js/42.438dab03.js"><link rel="prefetch" href="/assets/js/43.c979887a.js"><link rel="prefetch" href="/assets/js/44.9420c61d.js"><link rel="prefetch" href="/assets/js/45.33e4f9e2.js"><link rel="prefetch" href="/assets/js/46.f3cbef9c.js"><link rel="prefetch" href="/assets/js/47.fb5936ef.js"><link rel="prefetch" href="/assets/js/48.60438c12.js"><link rel="prefetch" href="/assets/js/49.f8d33107.js"><link rel="prefetch" href="/assets/js/5.38e381d7.js"><link rel="prefetch" href="/assets/js/50.8a141be7.js"><link rel="prefetch" href="/assets/js/51.e66be149.js"><link rel="prefetch" href="/assets/js/52.01b5d591.js"><link rel="prefetch" href="/assets/js/53.5f75e288.js"><link rel="prefetch" href="/assets/js/54.b800f5ab.js"><link rel="prefetch" href="/assets/js/55.5ec83bab.js"><link rel="prefetch" href="/assets/js/56.cb352d50.js"><link rel="prefetch" href="/assets/js/57.abd5cb67.js"><link rel="prefetch" href="/assets/js/58.247575be.js"><link rel="prefetch" href="/assets/js/59.fe2ea4c4.js"><link rel="prefetch" href="/assets/js/6.94e6c325.js"><link rel="prefetch" href="/assets/js/60.6ca1dbf2.js"><link rel="prefetch" href="/assets/js/61.17827b92.js"><link rel="prefetch" href="/assets/js/62.555b4828.js"><link rel="prefetch" href="/assets/js/63.84ca6822.js"><link rel="prefetch" href="/assets/js/64.3ad6991c.js"><link rel="prefetch" href="/assets/js/65.4ceba325.js"><link rel="prefetch" href="/assets/js/66.974a3e9f.js"><link rel="prefetch" href="/assets/js/67.b28920e9.js"><link rel="prefetch" href="/assets/js/68.414e9dcb.js"><link rel="prefetch" href="/assets/js/69.243e7e58.js"><link rel="prefetch" href="/assets/js/7.4c950058.js"><link rel="prefetch" href="/assets/js/70.edce6905.js"><link rel="prefetch" href="/assets/js/71.1597ac0b.js"><link rel="prefetch" href="/assets/js/72.df434d68.js"><link rel="prefetch" href="/assets/js/73.7eb59665.js"><link rel="prefetch" href="/assets/js/74.395e3edc.js"><link rel="prefetch" href="/assets/js/75.5f1f8b39.js"><link rel="prefetch" href="/assets/js/76.f7fd1846.js"><link rel="prefetch" href="/assets/js/77.218c2e3e.js"><link rel="prefetch" href="/assets/js/78.0f55efd4.js"><link rel="prefetch" href="/assets/js/79.5eb3d3e2.js"><link rel="prefetch" href="/assets/js/80.99a11cfb.js"><link rel="prefetch" href="/assets/js/81.384897a1.js"><link rel="prefetch" href="/assets/js/82.7e5ff056.js"><link rel="prefetch" href="/assets/js/83.661009cc.js"><link rel="prefetch" href="/assets/js/84.27dc6cec.js"><link rel="prefetch" href="/assets/js/85.2dfaa1d1.js"><link rel="prefetch" href="/assets/js/86.efe2a923.js"><link rel="prefetch" href="/assets/js/87.5ef2b325.js"><link rel="prefetch" href="/assets/js/88.35aad6b2.js"><link rel="prefetch" href="/assets/js/89.3c8af6e3.js"><link rel="prefetch" href="/assets/js/90.96eae265.js"><link rel="prefetch" href="/assets/js/91.ba662ab3.js"><link rel="prefetch" href="/assets/js/92.e95021d1.js"><link rel="prefetch" href="/assets/js/93.98e09b16.js"><link rel="prefetch" href="/assets/js/94.88c31113.js"><link rel="prefetch" href="/assets/js/95.fd90d734.js"><link rel="prefetch" href="/assets/js/96.4637c8fd.js"><link rel="prefetch" href="/assets/js/97.cbfb4df6.js"><link rel="prefetch" href="/assets/js/98.ab051256.js"><link rel="prefetch" href="/assets/js/99.9b434dc7.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.098fd5b4.js">
    <link rel="stylesheet" href="/assets/css/0.styles.49d708b7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">冯手力-java学习之路</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/操作/" class="nav-link">
  操作
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="经验" class="dropdown-title"><span class="title">经验</span> <span class="arrow down"></span></button> <button type="button" aria-label="经验" class="mobile-dropdown-title"><span class="title">经验</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/工作经验/" class="nav-link">
  工作经验
</a></li><li class="dropdown-item"><!----> <a href="/项目经验/" class="nav-link">
  项目经验
</a></li></ul></div></div><div class="nav-item"><a href="/java/" class="nav-link">
  java
</a></div><div class="nav-item"><a href="/架构之路/" class="nav-link">
  架构之路
</a></div><div class="nav-item"><a href="/领域驱动设计/" class="nav-link">
  领域驱动设计
</a></div><div class="nav-item"><a href="/源码解析/" class="nav-link">
  源码解析
</a></div><div class="nav-item"><a href="/程序员英语/" class="nav-link">
  程序员英语
</a></div><div class="nav-item"><a href="/面试突击班/" class="nav-link">
  面试突击班
</a></div><div class="nav-item"><a href="/算法体系/" class="nav-link">
  算法体系
</a></div><div class="nav-item"><a href="/用友/" class="nav-link">
  用友
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/操作/" class="nav-link">
  操作
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="经验" class="dropdown-title"><span class="title">经验</span> <span class="arrow down"></span></button> <button type="button" aria-label="经验" class="mobile-dropdown-title"><span class="title">经验</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/工作经验/" class="nav-link">
  工作经验
</a></li><li class="dropdown-item"><!----> <a href="/项目经验/" class="nav-link">
  项目经验
</a></li></ul></div></div><div class="nav-item"><a href="/java/" class="nav-link">
  java
</a></div><div class="nav-item"><a href="/架构之路/" class="nav-link">
  架构之路
</a></div><div class="nav-item"><a href="/领域驱动设计/" class="nav-link">
  领域驱动设计
</a></div><div class="nav-item"><a href="/源码解析/" class="nav-link">
  源码解析
</a></div><div class="nav-item"><a href="/程序员英语/" class="nav-link">
  程序员英语
</a></div><div class="nav-item"><a href="/面试突击班/" class="nav-link">
  面试突击班
</a></div><div class="nav-item"><a href="/算法体系/" class="nav-link">
  算法体系
</a></div><div class="nav-item"><a href="/用友/" class="nav-link">
  用友
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB%E7%8F%AD/" aria-current="page" class="sidebar-link">面试突击</a></li><li><a href="/面试突击班/面试表达.html" class="sidebar-link">面试表达</a></li><li><a href="/面试突击班/基础面试题.html" class="sidebar-link">基础面试题</a></li><li><a href="/面试突击班/多线程与IO.html" class="sidebar-link">多线程与IO</a></li><li><a href="/面试突击班/JVM面试突击班2025.html" class="sidebar-link">JVM面试突击班2025-1</a></li><li><a href="/面试突击班/JVM2024-下.html" class="sidebar-link">JVM2024-下</a></li><li><a href="/面试突击班/JVM2024-上.html" class="sidebar-link">JVM2024-上</a></li><li><a href="/面试突击班/redis2025.html" class="sidebar-link">redis2025-上</a></li><li><a href="/面试突击班/redis2024-下.html" class="sidebar-link">redis2024-下</a></li><li><a href="/面试突击班/redis2024-上.html" class="sidebar-link">redis2024-上</a></li><li><a href="/面试突击班/Mysql.html" class="sidebar-link">Mysql</a></li><li><a href="/面试突击班/Mysql2024-下.html" class="sidebar-link">MySQL2024-下</a></li><li><a href="/面试突击班/并发编程2025.html" class="sidebar-link">并发编程-2025</a></li><li><a href="/面试突击班/并发编程2024.html" class="sidebar-link">并发编程2024-1</a></li><li><a href="/面试突击班/Spring-2024下.html" class="sidebar-link">Spring-2024下</a></li><li><a href="/面试突击班/Spring-2024上.html" class="sidebar-link">Spring-2024上</a></li><li><a href="/面试突击班/MQ2025上.html" class="sidebar-link">MQ-2025上</a></li><li><a href="/面试突击班/MQ2024下.html" class="sidebar-link">MQ-2024下</a></li><li><a href="/面试突击班/MQ2024上.html" class="sidebar-link">MQ-2024上</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="rabbitmq的消息处理模型"><a href="#rabbitmq的消息处理模型" class="header-anchor">#</a> RabbitMQ的消息处理模型</h2> <h3 id="rabbitmq的消息处理模型-2"><a href="#rabbitmq的消息处理模型-2" class="header-anchor">#</a> RabbitMQ的消息处理模型</h3> <p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1741771732097/4f590d5614994010b10b50df6696625f.png" alt="image.png"></p> <p>RabbitMQ 是一个基于 <strong>AMQP（Advanced Message Queuing Protocol）</strong> 协议的消息队列系统</p> <ol><li><strong>生产者（Producer）</strong></li> <li><strong>交换器（Exchange）</strong></li> <li><strong>路由键（Routing Key）</strong></li> <li><strong>队列（Queue）</strong></li> <li><strong>消费者（Consumer）</strong></li> <li><strong>生产者（Producer）</strong></li></ol> <p>生产者是消息的发送者，负责创建消息并将其发送到 RabbitMQ 的交换器（Exchange）。</p> <p>生产者通过 <code>RabbitTemplate</code> 或 AMQP 客户端将消息发送到交换器</p> <ol start="2"><li><strong>交换器（Exchange）</strong></li></ol> <p>交换器是消息的路由中心，负责接收生产者发送的消息，并根据 <strong>路由键（Routing Key）</strong> 和 <strong>绑定规则（Binding）</strong> 将消息分发到一个或多个队列。</p> <ul><li><p><strong>类型</strong> ：RabbitMQ 支持多种交换器类型，每种类型有不同的路由规则：</p> <ul><li><strong>Direct Exchange</strong> ：精确匹配路由键。</li> <li><strong>Topic Exchange</strong> ：基于通配符匹配路由键。</li> <li><strong>Fanout Exchange</strong> ：广播消息到所有绑定的队列。</li></ul></li></ul> <p><strong>3.路由键（Routing Key）</strong></p> <p>路由键是生产者发送消息时指定的一个字符串，用于决定消息如何从交换器路由到队列。</p> <ul><li><strong>作用</strong> ：交换器根据路由键和绑定规则将消息分发到队列。</li> <li><strong>匹配规则</strong> ：不同的交换器类型对路由键的匹配方式不同。</li></ul> <p><strong>4.队列（Queue）</strong></p> <p>队列是消息的存储容器，用于存储从交换器路由过来的消息，直到消费者处理它们。</p> <p><strong>5.消费者（Consumer）</strong></p> <p>消费者是消息的接收者，负责从队列中获取消息并进行处理。</p> <ul><li>消费者订阅队列，RabbitMQ 会将队列中的消息推送给消费者。</li> <li>消费者处理完消息后，需要向 RabbitMQ 发送确认（ACK），表示消息已成功处理。</li></ul> <h3 id="kafka的消息处理模型"><a href="#kafka的消息处理模型" class="header-anchor">#</a> Kafka的消息处理模型</h3> <p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1741771732097/1e0c8c3c62c141e99722484d42d524eb.png" alt="image.png"></p> <p>Kafka 是一个分布式的流处理平台，其消息处理模型基于  <strong>发布-订阅模式</strong> ，核心组件包括  <strong>生产者（Producer）</strong> 、 <strong>Kafka 集群（Brokers）</strong> 、 <strong>主题（Topic）</strong> 、<strong>分区（Partition）</strong> 和 <strong>消费者（Consumer）</strong></p> <ol><li><p><strong>生产者发送消息</strong> ：</p> <ul><li>生产者将消息发送到  <strong>主题 A</strong> 。</li> <li>根据消息的键（Key）或轮询策略，消息被分配到 <strong>分区 0</strong> 或  <strong>分区 1</strong> 。</li></ul></li> <li><p><strong>消息存储</strong> ：</p> <ul><li>如果消息被分配到  <strong>分区 0</strong> ，它会被存储在 <strong>Broker1</strong> 上（因为 <strong>分区 0</strong> 的首领在 <strong>Broker1</strong> 上）。</li> <li>如果消息被分配到  <strong>分区 1</strong> ，它会被存储在 <strong>Broker2</strong> 上（因为 <strong>分区 1</strong> 的首领在 <strong>Broker2</strong> 上）。</li></ul></li> <li><p><strong>消费者消费消息</strong> ：</p> <ul><li>消费者组中的消费者订阅  <strong>主题 A</strong> 。</li> <li>消费者 1 从  <strong>分区 0</strong> （位于  <strong>Broker1</strong> ）读取消息。</li> <li>消费者 2 从  <strong>分区 1</strong> （位于  <strong>Broker2</strong> ）读取消息。</li></ul></li> <li><p><strong>并行处理</strong> ：</p> <ul><li>由于 <strong>分区 0</strong> 和 <strong>分区 1</strong> 位于不同的 Broker 上，消费者可以并行处理消息，提高吞吐量。</li></ul></li></ol> <p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1741771732097/a4808612869a40d89fd8804e8920c7ea.png" alt="image.png"></p> <h3 id="rocketmq的消息处理模型"><a href="#rocketmq的消息处理模型" class="header-anchor">#</a> RocketMQ的消息处理模型</h3> <p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1741771732097/bd46b03127ce4ccabbdcecc0c8ce6f9e.png" alt="image.png"></p> <p>RocketMQ 是一个分布式消息中间件，其消息处理模型基于  <strong>发布-订阅模式</strong> ，核心组件包括  <strong>生产者（Producer）</strong> 、 <strong>Broker</strong> 、 <strong>NameServer</strong> 、<strong>主题（Topic）、队列</strong> 和 <strong>消费者（Consumer）</strong></p> <p>NameServer 是 RocketMQ 的轻量级服务发现组件，负责管理 Broker 的路由信息。</p> <p>Broker 是 RocketMQ 的消息存储和转发节点，负责存储消息、处理生产者和消费者的请求。</p> <p><strong>主题（Topic）</strong></p> <ul><li>主题可以创建在一台 Master 上，也可以创建在多台 Master 上以提高并发能力。</li> <li>如果主题创建在多台 Master 上，消息会被均匀分布到不同的 Master。</li></ul> <p><strong>消息处理流程</strong></p> <ol><li><strong>主题创建</strong> ：
<ul><li><strong>主题 A</strong> 可以创建在 <strong>Master1</strong> 上，也可以同时创建在 <strong>Master1</strong> 和 <strong>Master2</strong> 上。</li> <li>如果创建在 <strong>Master1</strong> 和 <strong>Master2</strong> 上，消息会被均匀分布到两个 Master，提高并发能力。</li></ul></li> <li><strong>生产者发送消息</strong> ：
<ul><li>生产者将消息发送到  <strong>主题 A</strong> 。</li> <li>如果 <strong>主题 A</strong> 创建在 <strong>Master1</strong> 和 <strong>Master2</strong> 上，消息会被均匀分布到 <strong>Master1</strong> 和  <strong>Master2</strong> 。</li></ul></li> <li><strong>消息存储</strong> ：
<ul><li>消息被存储在 <strong>Master1</strong> 或 <strong>Master2</strong> 的队列中。</li> <li><strong>Slave1</strong> 和 <strong>Slave2</strong> 分别从 <strong>Master1</strong> 和 <strong>Master2</strong> 同步数据，提供数据备份。</li></ul></li> <li><strong>消费者消费消息</strong> ：
<ul><li>消费者从 <strong>Master1</strong> 或 <strong>Master2</strong> 的队列中拉取消息。</li> <li>如果 <strong>Master1</strong> 阻塞或宕机，消费者可以从 <strong>Slave1</strong> 消费消息。</li> <li>如果 <strong>Master2</strong> 阻塞或宕机，消费者可以从 <strong>Slave2</strong> 消费消息。</li></ul></li></ol> <h2 id="如何在mq中实现消息的顺序性-分析相关的设计与实现细节"><a href="#如何在mq中实现消息的顺序性-分析相关的设计与实现细节" class="header-anchor">#</a> 如何在MQ中实现消息的顺序性，分析相关的设计与实现细节！</h2> <p>为了保证消息的顺序性，通常需要遵循以下规则：</p> <ul><li><strong>单线程生产</strong> ：确保生产者以单线程方式发送消息，避免并发发送导致消息乱序。</li> <li><strong>单线程消费</strong> ：确保消费者以单线程方式消费消息，避免并发消费导致消息乱序。</li> <li><strong>单个队列</strong> ：将所有消息发送到同一个队列中，确保消息的顺序性。</li> <li><strong>单个生产者/消费者</strong> ：避免多个生产者或消费者同时操作同一个队列，导致消息顺序混乱。</li></ul> <h3 id="rabbitmq"><a href="#rabbitmq" class="header-anchor">#</a> RabbitMQ</h3> <p>消息重试机制可以确保消息在消费失败后重新入队，从而保证消息的顺序性。</p> <p>如果消费者处理消息失败，将消息重新放回队列头部，确保消息顺序不变。</p> <h4 id="事务消息"><a href="#事务消息" class="header-anchor">#</a> <strong>事务消息</strong></h4> <p>事务消息可以确保消息的发送和业务逻辑的原子性，从而保证消息的顺序性。</p> <p>如果对消息顺序性要求极高，且可以接受性能损失，可以选择  <strong>事务消息</strong> 。</p> <h4 id="rpc-模式"><a href="#rpc-模式" class="header-anchor">#</a> <strong>RPC 模式</strong></h4> <p>RPC 模式可以确保消息的顺序性，通过同步调用方式实现。</p> <p>如果需要同步调用并保证顺序性，可以选择  <strong>RPC 模式</strong> 。</p> <h3 id="kafka和rocketmq"><a href="#kafka和rocketmq" class="header-anchor">#</a> Kafka和RocketMQ</h3> <p>在 Kafka 和RocketMQ中，一个分区/队列只能被同一个消费者组中的一个消费者消费。通过限制消费者组的消费者数量，可以确保消息的顺序性。</p> <p>Kafka中：</p> <p><code>max.in.flight.requests.per.connection</code>：**控制每个连接上未确认的请求数量。设置为1</p> <p>RocketMQ中：
选用顺序的消费者方法或者类。</p> <h1 id="描述mq中的消息确认机制-如rabbitmq-rocketmq的ack机制-分析源码中如何处理消息的确认与重发"><a href="#描述mq中的消息确认机制-如rabbitmq-rocketmq的ack机制-分析源码中如何处理消息的确认与重发" class="header-anchor">#</a> 描述MQ中的消息确认机制（如RabbitMQ\RocketMQ的ack机制），分析源码中如何处理消息的确认与重发</h1> <p>RabbitMQ与Kafka和RocketMQ不一样，进行完ACK确认后，RabbitMQ会删除消息，其他的（kafka和RocketMQ）他们是不会删除，只会进行消费偏移量管理的。</p> <p>RocketMQ 的消息确认机制基于 <strong>消费者拉取消息</strong> 和  <strong>消费进度提交</strong> 。</p> <p>Kafka 的消息确认机制基于  <strong>消费者提交偏移量（Offset）</strong> 。</p> <ol><li><strong>RabbitMQ</strong> ：
<ul><li>通过 Confirm 模式和手动 ACK 确保消息可靠传递。</li> <li>支持 NACK 重新入队和重试机制。</li></ul></li> <li><strong>RocketMQ</strong> ：
<ul><li>通过消费进度提交确保消息可靠传递。</li> <li>支持重试队列，提供多级别重试策略。</li></ul></li> <li><strong>Kafka</strong> ：
<ul><li>通过偏移量提交确保消息可靠传递。</li> <li>无内置重试机制，需开发者自行实现。</li></ul></li></ol> <p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1741771732097/7d7d124ee1034adc8d8cde095c146667.png" alt="image.png"></p> <h1 id="使用mq的延迟消息实现限时订单"><a href="#使用mq的延迟消息实现限时订单" class="header-anchor">#</a> 使用MQ的延迟消息实现限时订单</h1> <h2 id="rabbitmq-2"><a href="#rabbitmq-2" class="header-anchor">#</a> RabbitMQ</h2> <p>RabbitMQ本身不支持延迟消息，但可以通过死信队列（DLX）和消息TTL（Time-To-Live）来实现延迟效果。</p> <ol><li><strong>创建普通队列和死信队列</strong> ：
<ul><li>创建一个普通队列，并设置消息的TTL（即消息的存活时间）。</li> <li>创建一个死信队列，用于接收超时的消息。</li></ul></li> <li><strong>绑定死信队列</strong> ：
<ul><li>在普通队列中配置死信交换器（DLX），当消息在普通队列中过期后，会被转发到死信队列。</li></ul></li> <li><strong>发送延迟消息</strong> ：
<ul><li>当用户下单时，将订单信息发送到普通队列，并设置消息的TTL为订单的超时时间（如30分钟）。</li></ul></li> <li><strong>处理超时订单</strong> ：
<ul><li>消费者监听死信队列，当消息从普通队列过期并进入死信队列时，消费者会收到该消息，表示订单超时，可以进行取消订单等操作。</li></ul></li></ol> <h2 id="rocketmq-延时消息"><a href="#rocketmq-延时消息" class="header-anchor">#</a> RocketMQ：延时消息</h2> <p>RocketMQ原生支持延迟消息，可以直接设置消息的延迟级别来实现订单超时处理。在RocketMQ5的版本中可以设置任意的延迟时间。</p> <div class="language- extra-class"><pre class="language-text"><code>// 设置延迟级别，3对应10分钟，4对应30分钟
        msg.setDelayTimeLevel(4);
</code></pre></div><ul><li><p>在RocketMQ 5.x中，发送消息时可以通过 <code>setDelayTimeMs</code>方法设置任意的延迟时间（以毫秒为单位）。</p></li> <li><p>例如，设置延迟30分钟，可以将延迟时间设置为 <code>30 * 60 * 1000</code>毫秒。</p> <p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1741771732097/5fb71145309f471986c48594e3505c28.png" alt="image.png"></p></li></ul> <div class="language- extra-class"><pre class="language-text"><code> Message message = provider.newMessageBuilder()
                .setTopic(&quot;order_topic&quot;)
                .setBody(body)
                .setDelayTimeMs(30 * 60 * 1000) // 设置延迟时间（30分钟）
                .build();
</code></pre></div><h1 id="在支付系统中-如何利用mq处理支付请求-确保支付的可靠性和事务的一致性"><a href="#在支付系统中-如何利用mq处理支付请求-确保支付的可靠性和事务的一致性" class="header-anchor">#</a> 在支付系统中，如何利用MQ处理支付请求，确保支付的可靠性和事务的一致性</h1> <p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1741771732097/63a28a27282b4309a668464c9200dd01.png" alt="image.png"></p> <p>其他的细讲见代码</p> <h1 id="mq中流量控制的实现-包括限流策略和流量监控-分析源码中相关的实现逻辑"><a href="#mq中流量控制的实现-包括限流策略和流量监控-分析源码中相关的实现逻辑" class="header-anchor">#</a> MQ中流量控制的实现，包括限流策略和流量监控，分析源码中相关的实现逻辑</h1> <h2 id="rabbitmq-3"><a href="#rabbitmq-3" class="header-anchor">#</a> <strong>RabbitMQ</strong></h2> <p>通过设置消费者的预取数量（prefetch count），可以限制消费者从队列中拉取的消息数量，从而控制消费速率。</p> <div class="language- extra-class"><pre class="language-text"><code> @Bean
    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(ConnectionFactory connectionFactory) {
        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory);
        // 设置 prefetchCount，限制消费者每次从队列中拉取的消息数量
        factory.setPrefetchCount(10); // 每次最多拉取 10 条消息
        return factory;
    }

</code></pre></div><h2 id="kafka"><a href="#kafka" class="header-anchor">#</a> <strong>Kafka</strong></h2> <h3 id="生产者"><a href="#生产者" class="header-anchor">#</a> 生产者</h3> <p>通过配置 <code>producer.properties</code> 中的 <code>max.in.flight.requests.per.connection</code> 和 <code>linger.ms</code> 参数，控制生产者的发送速率。</p> <div class="language- extra-class"><pre class="language-text"><code>       // 设置 max.in.flight.requests.per.connection
        props.put(ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION, 1);
        // 设置 linger.ms
        props.put(ProducerConfig.LINGER_MS_CONFIG, 100);
</code></pre></div><p><code>max.in.flight.requests.per.connection</code>：**控制每个连接上未确认的请求数量。</p> <ul><li><p><strong>未确认请求</strong> ：
未确认请求是指生产者已经发送给 Broker 但尚未收到确认（acknowledgment）的消息。</p></li> <li><p><strong>并发性</strong> ：
增加该值可以提高生产者的并发性，从而提升吞吐量，因为生产者可以同时发送更多的消息。</p></li> <li><p><strong>顺序性</strong> ：
如果该值大于 1，可能会导致消息乱序。例如：</p> <ul><li>假设生产者发送了消息 A 和消息 B。</li> <li>如果消息 A 发送失败并重试，而消息 B 已经成功发送，那么消息 B 可能会先于消息 A 被写入分区，导致消息顺序错乱。</li> <li>如果需要严格保证消息顺序，建议将该值设置为 <code>1</code>。</li></ul></li></ul> <h3 id="消费者"><a href="#消费者" class="header-anchor">#</a> <strong>消费者</strong></h3> <p>使用 Kafka 的 <code>fetch.max.bytes</code> 和 <code>max.poll.records</code> 参数控制消费者每次拉取的消息数量。</p> <p>它们分别用于控制每次拉取的最大字节数和最大消息数。</p> <p><code>fetch.max.bytes</code>：该参数限制了消费者每次从 Kafka Broker 拉取数据的最大字节数。它决定了消费者单次请求能够获取的数据量。</p> <ul><li><strong>影响拉取的数据量</strong> ：
如果设置的值较小，消费者每次拉取的数据量会减少，从而降低网络带宽的占用，但可能会增加拉取请求的频率。</li> <li><strong>与分区大小的关系</strong> ：
如果单个分区中的数据量超过了 <code>fetch.max.bytes</code>，消费者仍然会拉取整个分区的数据，因此该参数并不能严格限制单次拉取的数据量。</li></ul> <p>max.poll.records：控制每次拉取的最大消息数：</p> <p>该参数限制了消费者每次调用 poll() 方法时返回的最大消息数。</p> <ul><li><strong>影响单次处理的消息量</strong> ：
如果设置的值较小，消费者每次处理的消息数量会减少，从而降低单次处理的开销，但可能会增加 <code>poll()</code> 方法的调用频率。</li> <li><strong>与消费者处理能力的关系</strong> ：
如果消费者的处理能力有限，可以适当减小该值，以避免消息积压。</li> <li><strong>适用场景</strong> ：
<ul><li>如果消费者的处理速度较慢，可以减小该值以避免消息堆积。</li> <li>如果需要减少单次处理的消息量以降低内存占用，也可以调整该值。</li></ul></li></ul> <p><strong>综合</strong></p> <ul><li><strong>消费者处理能力</strong> ：
如果消费者的处理速度较慢，可以适当减小 <code>max.poll.records</code> 的值，以避免消息堆积。</li> <li><strong>网络带宽</strong> ：
如果网络带宽有限，可以适当减小 <code>fetch.max.bytes</code> 的值，以减少单次拉取的数据量。</li> <li><strong>与 <code>max.poll.interval.ms</code> 的关系</strong> ：
<code>max.poll.interval.ms</code> 参数定义了消费者两次 <code>poll()</code> 调用之间的最大时间间隔。如果消费者处理消息的时间过长，可能会导致消费者被踢出组（rebalance）。因此，在调整 <code>max.poll.records</code> 时，也需要考虑 <code>max.poll.interval.ms</code> 的设置。</li></ul> <h2 id="rocketmq"><a href="#rocketmq" class="header-anchor">#</a> RocketMQ</h2> <h4 id="生产者限流"><a href="#生产者限流" class="header-anchor">#</a> <strong>生产者限流</strong></h4> <p><strong>发送速率限制</strong> ：
通过设置 <code>sendMsgTimeout</code> 和 <code>maxMessageSize</code> 参数，控制生产者的发送速率。</p> <ul><li><p><strong><code>sendMsgTimeout</code>作用</strong> ：
该参数用于设置生产者发送消息的超时时间。如果消息在指定时间内未发送成功，生产者会抛出超时异常。</p></li> <li><p><strong>默认值</strong> ：
默认值为 <code>3000</code>（即 3 秒）。</p></li> <li><p><strong>适用场景</strong> ：</p> <ul><li>如果网络延迟较高或 Broker 处理较慢，可以适当增加该值。</li> <li>如果需要快速失败（fail-fast），可以减小该值。</li></ul></li> <li><p><strong><code>maxMessageSize：</code>作用</strong> ：
该参数用于设置单条消息的最大大小。如果消息大小超过该值，生产者会抛出异常。</p></li> <li><p><strong>默认值</strong> ：
默认值为 <code>4 MB</code>（即 <code>4194304</code> 字节）。</p></li> <li><p><strong>适用场景</strong> ：</p> <ul><li>如果需要发送较大的消息，可以适当增加该值。</li> <li>如果对消息大小有严格限制，可以减小该值。</li></ul></li></ul> <h4 id="消费者限流"><a href="#消费者限流" class="header-anchor">#</a> <strong>消费者限流</strong></h4> <p><strong>拉取速率限制</strong> ：
通过设置 <code>pullBatchSize</code> 和 <code>pullInterval</code> 参数，控制消费者的拉取速率。</p> <p><code>pullBatchSize</code></p> <ul><li><strong>作用</strong> ：
该参数用于设置消费者每次从 Broker 拉取的消息数量。</li> <li><strong>默认值</strong> ：
默认值为 <code>32</code>。</li> <li><strong>适用场景</strong> ：
<ul><li>如果消费者的处理能力较强，可以适当增加该值以提高吞吐量。</li> <li>如果消费者的处理能力有限，可以减小该值以避免消息堆积。</li></ul></li></ul> <p><code>pullInterval</code></p> <ul><li><strong>作用</strong> ：
该参数用于设置消费者两次拉取操作之间的时间间隔（毫秒）。</li> <li><strong>默认值</strong> ：
默认值为 <code>0</code>，表示消费者会立即进行下一次拉取。</li> <li><strong>适用场景</strong> ：
<ul><li>如果需要降低消费者的拉取频率，可以适当增加该值。</li> <li>如果需要实时处理消息，可以减小该值。</li></ul></li></ul> <h1 id="mq系统如何实现高可用性-如集群模式、主从复制等"><a href="#mq系统如何实现高可用性-如集群模式、主从复制等" class="header-anchor">#</a> MQ系统如何实现高可用性（如集群模式、主从复制等）</h1> <h2 id="rabbitmq-4"><a href="#rabbitmq-4" class="header-anchor">#</a> RabbitMQ</h2> <p>RabbitMQ一般是通过镜像队列来实现高可用。（RabbitMQ的集群功能不行，消息本身不会在集群节点之间复制，如果某个节点故障，其上的队列和消息将不可用）</p> <p>镜像队列实现方式</p> <ul><li><strong>主从复制</strong> ：
每个队列可以配置多个镜像（副本），分布在不同的节点上。主节点负责处理消息，从节点同步主节点的数据。</li> <li><strong>自动故障转移</strong> ：
如果主节点故障，RabbitMQ 会自动选举一个从节点作为新的主节点。</li></ul> <h2 id="rocketmq-2"><a href="#rocketmq-2" class="header-anchor">#</a> RocketMQ</h2> <h3 id="_2-1-主从复制"><a href="#_2-1-主从复制" class="header-anchor">#</a> 2.1 主从复制</h3> <p>RocketMQ 通过 <strong>主从复制</strong> 实现高可用性。</p> <h4 id="实现方式"><a href="#实现方式" class="header-anchor">#</a> 实现方式</h4> <ul><li><strong>Broker 主从架构</strong> ：
每个 Broker 组包含一个主节点（Master）和多个从节点（Slave）。主节点负责处理读写请求，从节点同步主节点的数据。</li> <li><strong>消息同步</strong> ：
主节点将消息同步到从节点，确保从节点上有完整的数据副本。</li> <li><strong>故障转移</strong> ：
如果主节点故障，RocketMQ 会自动切换到从节点继续提供服务。</li></ul> <h4 id="配置步骤"><a href="#配置步骤" class="header-anchor">#</a> 配置步骤</h4> <ol><li><p>部署多个 Broker 组，每个组包含一个主节点和多个从节点。</p></li> <li><p>在配置文件中指定主从关系：
properties</p> <p>复制</p> <div class="language- extra-class"><pre class="language-text"><code>brokerClusterName=DefaultCluster
brokerName=broker-a
brokerId=0 # 0 表示主节点，大于 0 表示从节点
</code></pre></div></li> <li><p>客户端配置 NameServer 地址，NameServer 会管理 Broker 的主从关系。</p></li></ol> <h4 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h4> <ul><li>提高消息的可用性和可靠性。</li> <li>自动故障转移，保证服务连续性。</li></ul> <h4 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h4> <ul><li>从节点只提供读服务，写操作仍然依赖主节点。</li></ul> <hr> <h3 id="_2-2-dledger-模式-raft-协议"><a href="#_2-2-dledger-模式-raft-协议" class="header-anchor">#</a> 2.2 DLedger 模式（Raft 协议）</h3> <p>RocketMQ 4.5 及以上版本支持  <strong>DLedger 模式</strong> ，基于 Raft 协议实现高可用性。</p> <h4 id="实现方式-2"><a href="#实现方式-2" class="header-anchor">#</a> 实现方式</h4> <ul><li><strong>多副本一致性</strong> ：
使用 Raft 协议保证多个副本之间的一致性。</li> <li><strong>自动选举</strong> ：
如果主节点故障，DLedger 会自动选举新的主节点。</li></ul> <h4 id="配置步骤-2"><a href="#配置步骤-2" class="header-anchor">#</a> 配置步骤</h4> <ol><li><p>在 Broker 配置文件中启用 DLedger：
properties</p> <p>复制</p> <div class="language- extra-class"><pre class="language-text"><code>enableDLegerCommitLog=true
dLegerGroup=broker-a
dLegerPeers=n0-127.0.0.1:40911;n1-127.0.0.1:40912;n2-127.0.0.1:40913
</code></pre></div></li> <li><p>启动多个 Broker 节点，每个节点运行一个 DLedger 实例。</p></li></ol> <h4 id="优点-2"><a href="#优点-2" class="header-anchor">#</a> 优点</h4> <ul><li>强一致性，保证数据不丢失。</li> <li>自动故障转移，提高系统可用性。</li></ul> <h4 id="缺点-2"><a href="#缺点-2" class="header-anchor">#</a> 缺点</h4> <ul><li>增加了系统复杂性和性能开销。</li></ul> <hr> <h2 id="_3-kafka"><a href="#_3-kafka" class="header-anchor">#</a> 3. Kafka</h2> <h3 id="_3-1-分区副本机制"><a href="#_3-1-分区副本机制" class="header-anchor">#</a> 3.1 分区副本机制</h3> <p>Kafka 通过 <strong>分区副本</strong> 机制实现高可用性。</p> <h4 id="实现方式-3"><a href="#实现方式-3" class="header-anchor">#</a> 实现方式</h4> <ul><li><strong>分区和副本</strong> ：
每个主题（Topic）分为多个分区（Partition），每个分区可以有多个副本（Replica），分布在不同的 Broker 上。</li> <li><strong>主从复制</strong> ：
每个分区有一个主副本（Leader）和多个从副本（Follower）。主副本负责处理读写请求，从副本同步主副本的数据。</li> <li><strong>故障转移</strong> ：
如果主副本故障，Kafka 会从从副本中选举一个新的主副本。</li></ul> <h4 id="配置步骤-3"><a href="#配置步骤-3" class="header-anchor">#</a> 配置步骤</h4> <ol><li><p>创建主题时指定分区和副本数：
bash</p> <p>复制</p> <div class="language- extra-class"><pre class="language-text"><code>kafka-topics.sh --create --topic my-topic --partitions 3 --replication-factor 2 --bootstrap-server localhost:9092
</code></pre></div><ul><li><code>partitions</code>：分区数。</li> <li><code>replication-factor</code>：副本数。</li></ul></li> <li><p>Kafka 会自动管理分区副本的分布和主从关系。</p></li></ol> <h4 id="优点-3"><a href="#优点-3" class="header-anchor">#</a> 优点</h4> <ul><li>提高消息的可用性和可靠性。</li> <li>自动故障转移，保证服务连续性。</li></ul> <h4 id="缺点-3"><a href="#缺点-3" class="header-anchor">#</a> 缺点</h4> <ul><li>副本数增加会占用更多的存储和网络带宽。</li></ul> <hr> <h3 id="_3-2-isr-机制"><a href="#_3-2-isr-机制" class="header-anchor">#</a> 3.2 ISR 机制</h3> <p>Kafka 使用 <strong>ISR（In-Sync Replicas）</strong> 机制来保证数据的一致性。</p> <h4 id="实现方式-4"><a href="#实现方式-4" class="header-anchor">#</a> 实现方式</h4> <ul><li><strong>ISR 集合</strong> ：
ISR 集合包含所有与主副本保持同步的从副本。</li> <li><strong>消息确认</strong> ：
生产者可以配置 <code>acks</code> 参数来控制消息的确认方式：
<ul><li><code>acks=0</code>：不等待确认。</li> <li><code>acks=1</code>：等待主副本确认。</li> <li><code>acks=all</code>：等待所有 ISR 副本确认。</li></ul></li></ul> <h4 id="优点-4"><a href="#优点-4" class="header-anchor">#</a> 优点</h4> <ul><li>灵活的消息确认机制，平衡性能和可靠性。</li> <li>保证数据的一致性。</li></ul> <h4 id="缺点-4"><a href="#缺点-4" class="header-anchor">#</a> 缺点</h4> <ul><li><code>acks=all</code> 会增加消息的延迟。</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e6553dd9.js" defer></script><script src="/assets/js/2.f327c6f6.js" defer></script><script src="/assets/js/1.65890b21.js" defer></script><script src="/assets/js/120.5d9edcac.js" defer></script>
  </body>
</html>
