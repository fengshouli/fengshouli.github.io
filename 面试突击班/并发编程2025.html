<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>并发编程-2025 | 冯手力-java学习之路</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.49d708b7.css" as="style"><link rel="preload" href="/assets/js/app.e6553dd9.js" as="script"><link rel="preload" href="/assets/js/2.f327c6f6.js" as="script"><link rel="preload" href="/assets/js/1.65890b21.js" as="script"><link rel="preload" href="/assets/js/53.5f75e288.js" as="script"><link rel="prefetch" href="/assets/js/10.28da0279.js"><link rel="prefetch" href="/assets/js/100.3f67ceba.js"><link rel="prefetch" href="/assets/js/101.1e6b498b.js"><link rel="prefetch" href="/assets/js/102.00199558.js"><link rel="prefetch" href="/assets/js/103.cb589f22.js"><link rel="prefetch" href="/assets/js/104.cab26ab3.js"><link rel="prefetch" href="/assets/js/105.bf01bd31.js"><link rel="prefetch" href="/assets/js/106.3896d2a8.js"><link rel="prefetch" href="/assets/js/107.940ed5bd.js"><link rel="prefetch" href="/assets/js/108.d0227db2.js"><link rel="prefetch" href="/assets/js/109.c4ea9421.js"><link rel="prefetch" href="/assets/js/11.499b1ef6.js"><link rel="prefetch" href="/assets/js/110.65523b02.js"><link rel="prefetch" href="/assets/js/111.4e289c06.js"><link rel="prefetch" href="/assets/js/112.37b56330.js"><link rel="prefetch" href="/assets/js/113.dee38bce.js"><link rel="prefetch" href="/assets/js/114.d54f016e.js"><link rel="prefetch" href="/assets/js/115.a5d342ba.js"><link rel="prefetch" href="/assets/js/116.61b42bbf.js"><link rel="prefetch" href="/assets/js/117.384fa39a.js"><link rel="prefetch" href="/assets/js/118.de70117e.js"><link rel="prefetch" href="/assets/js/119.301c1a9b.js"><link rel="prefetch" href="/assets/js/12.e2bb6bf6.js"><link rel="prefetch" href="/assets/js/120.5d9edcac.js"><link rel="prefetch" href="/assets/js/121.1030f828.js"><link rel="prefetch" href="/assets/js/122.93206142.js"><link rel="prefetch" href="/assets/js/123.160b984e.js"><link rel="prefetch" href="/assets/js/124.41c4322e.js"><link rel="prefetch" href="/assets/js/125.841832fa.js"><link rel="prefetch" href="/assets/js/126.ec3ffa0f.js"><link rel="prefetch" href="/assets/js/127.b0a0a372.js"><link rel="prefetch" href="/assets/js/128.4f847758.js"><link rel="prefetch" href="/assets/js/129.4298badb.js"><link rel="prefetch" href="/assets/js/13.6e92c677.js"><link rel="prefetch" href="/assets/js/14.50fc1271.js"><link rel="prefetch" href="/assets/js/15.53f9b1a9.js"><link rel="prefetch" href="/assets/js/16.2288ae4a.js"><link rel="prefetch" href="/assets/js/17.a67122e3.js"><link rel="prefetch" href="/assets/js/18.b5b3b2b0.js"><link rel="prefetch" href="/assets/js/19.98e5962f.js"><link rel="prefetch" href="/assets/js/20.c3553c70.js"><link rel="prefetch" href="/assets/js/21.3d794f8a.js"><link rel="prefetch" href="/assets/js/22.5e27acdb.js"><link rel="prefetch" href="/assets/js/23.572115ce.js"><link rel="prefetch" href="/assets/js/24.fa6ad6bf.js"><link rel="prefetch" href="/assets/js/25.ebec8bf4.js"><link rel="prefetch" href="/assets/js/26.11811683.js"><link rel="prefetch" href="/assets/js/27.da58e60d.js"><link rel="prefetch" href="/assets/js/28.5113a04f.js"><link rel="prefetch" href="/assets/js/29.b55cc958.js"><link rel="prefetch" href="/assets/js/3.00f65edc.js"><link rel="prefetch" href="/assets/js/30.0762efaf.js"><link rel="prefetch" href="/assets/js/31.47e1502f.js"><link rel="prefetch" href="/assets/js/32.9b69bd31.js"><link rel="prefetch" href="/assets/js/33.21a56e2a.js"><link rel="prefetch" href="/assets/js/34.5a9ada4b.js"><link rel="prefetch" href="/assets/js/35.8791941c.js"><link rel="prefetch" href="/assets/js/36.604d27ff.js"><link rel="prefetch" href="/assets/js/37.658cf2d4.js"><link rel="prefetch" href="/assets/js/38.71d8fd9e.js"><link rel="prefetch" href="/assets/js/39.e55e40ac.js"><link rel="prefetch" href="/assets/js/4.0c95c87a.js"><link rel="prefetch" href="/assets/js/40.259535fd.js"><link rel="prefetch" href="/assets/js/41.d6e85839.js"><link rel="prefetch" href="/assets/js/42.438dab03.js"><link rel="prefetch" href="/assets/js/43.c979887a.js"><link rel="prefetch" href="/assets/js/44.9420c61d.js"><link rel="prefetch" href="/assets/js/45.33e4f9e2.js"><link rel="prefetch" href="/assets/js/46.f3cbef9c.js"><link rel="prefetch" href="/assets/js/47.fb5936ef.js"><link rel="prefetch" href="/assets/js/48.60438c12.js"><link rel="prefetch" href="/assets/js/49.f8d33107.js"><link rel="prefetch" href="/assets/js/5.38e381d7.js"><link rel="prefetch" href="/assets/js/50.8a141be7.js"><link rel="prefetch" href="/assets/js/51.e66be149.js"><link rel="prefetch" href="/assets/js/52.01b5d591.js"><link rel="prefetch" href="/assets/js/54.b800f5ab.js"><link rel="prefetch" href="/assets/js/55.5ec83bab.js"><link rel="prefetch" href="/assets/js/56.cb352d50.js"><link rel="prefetch" href="/assets/js/57.abd5cb67.js"><link rel="prefetch" href="/assets/js/58.247575be.js"><link rel="prefetch" href="/assets/js/59.fe2ea4c4.js"><link rel="prefetch" href="/assets/js/6.94e6c325.js"><link rel="prefetch" href="/assets/js/60.6ca1dbf2.js"><link rel="prefetch" href="/assets/js/61.17827b92.js"><link rel="prefetch" href="/assets/js/62.555b4828.js"><link rel="prefetch" href="/assets/js/63.84ca6822.js"><link rel="prefetch" href="/assets/js/64.3ad6991c.js"><link rel="prefetch" href="/assets/js/65.4ceba325.js"><link rel="prefetch" href="/assets/js/66.974a3e9f.js"><link rel="prefetch" href="/assets/js/67.b28920e9.js"><link rel="prefetch" href="/assets/js/68.414e9dcb.js"><link rel="prefetch" href="/assets/js/69.243e7e58.js"><link rel="prefetch" href="/assets/js/7.4c950058.js"><link rel="prefetch" href="/assets/js/70.edce6905.js"><link rel="prefetch" href="/assets/js/71.1597ac0b.js"><link rel="prefetch" href="/assets/js/72.df434d68.js"><link rel="prefetch" href="/assets/js/73.7eb59665.js"><link rel="prefetch" href="/assets/js/74.395e3edc.js"><link rel="prefetch" href="/assets/js/75.5f1f8b39.js"><link rel="prefetch" href="/assets/js/76.f7fd1846.js"><link rel="prefetch" href="/assets/js/77.218c2e3e.js"><link rel="prefetch" href="/assets/js/78.0f55efd4.js"><link rel="prefetch" href="/assets/js/79.5eb3d3e2.js"><link rel="prefetch" href="/assets/js/80.99a11cfb.js"><link rel="prefetch" href="/assets/js/81.384897a1.js"><link rel="prefetch" href="/assets/js/82.7e5ff056.js"><link rel="prefetch" href="/assets/js/83.661009cc.js"><link rel="prefetch" href="/assets/js/84.27dc6cec.js"><link rel="prefetch" href="/assets/js/85.2dfaa1d1.js"><link rel="prefetch" href="/assets/js/86.efe2a923.js"><link rel="prefetch" href="/assets/js/87.5ef2b325.js"><link rel="prefetch" href="/assets/js/88.35aad6b2.js"><link rel="prefetch" href="/assets/js/89.3c8af6e3.js"><link rel="prefetch" href="/assets/js/90.96eae265.js"><link rel="prefetch" href="/assets/js/91.ba662ab3.js"><link rel="prefetch" href="/assets/js/92.e95021d1.js"><link rel="prefetch" href="/assets/js/93.98e09b16.js"><link rel="prefetch" href="/assets/js/94.88c31113.js"><link rel="prefetch" href="/assets/js/95.fd90d734.js"><link rel="prefetch" href="/assets/js/96.4637c8fd.js"><link rel="prefetch" href="/assets/js/97.cbfb4df6.js"><link rel="prefetch" href="/assets/js/98.ab051256.js"><link rel="prefetch" href="/assets/js/99.9b434dc7.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.098fd5b4.js">
    <link rel="stylesheet" href="/assets/css/0.styles.49d708b7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">冯手力-java学习之路</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/操作/" class="nav-link">
  操作
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="经验" class="dropdown-title"><span class="title">经验</span> <span class="arrow down"></span></button> <button type="button" aria-label="经验" class="mobile-dropdown-title"><span class="title">经验</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/工作经验/" class="nav-link">
  工作经验
</a></li><li class="dropdown-item"><!----> <a href="/项目经验/" class="nav-link">
  项目经验
</a></li></ul></div></div><div class="nav-item"><a href="/java/" class="nav-link">
  java
</a></div><div class="nav-item"><a href="/架构之路/" class="nav-link">
  架构之路
</a></div><div class="nav-item"><a href="/领域驱动设计/" class="nav-link">
  领域驱动设计
</a></div><div class="nav-item"><a href="/源码解析/" class="nav-link">
  源码解析
</a></div><div class="nav-item"><a href="/程序员英语/" class="nav-link">
  程序员英语
</a></div><div class="nav-item"><a href="/面试突击班/" class="nav-link">
  面试突击班
</a></div><div class="nav-item"><a href="/算法体系/" class="nav-link">
  算法体系
</a></div><div class="nav-item"><a href="/用友/" class="nav-link">
  用友
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/操作/" class="nav-link">
  操作
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="经验" class="dropdown-title"><span class="title">经验</span> <span class="arrow down"></span></button> <button type="button" aria-label="经验" class="mobile-dropdown-title"><span class="title">经验</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/工作经验/" class="nav-link">
  工作经验
</a></li><li class="dropdown-item"><!----> <a href="/项目经验/" class="nav-link">
  项目经验
</a></li></ul></div></div><div class="nav-item"><a href="/java/" class="nav-link">
  java
</a></div><div class="nav-item"><a href="/架构之路/" class="nav-link">
  架构之路
</a></div><div class="nav-item"><a href="/领域驱动设计/" class="nav-link">
  领域驱动设计
</a></div><div class="nav-item"><a href="/源码解析/" class="nav-link">
  源码解析
</a></div><div class="nav-item"><a href="/程序员英语/" class="nav-link">
  程序员英语
</a></div><div class="nav-item"><a href="/面试突击班/" class="nav-link">
  面试突击班
</a></div><div class="nav-item"><a href="/算法体系/" class="nav-link">
  算法体系
</a></div><div class="nav-item"><a href="/用友/" class="nav-link">
  用友
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB%E7%8F%AD/" aria-current="page" class="sidebar-link">面试突击</a></li><li><a href="/面试突击班/面试表达.html" class="sidebar-link">面试表达</a></li><li><a href="/面试突击班/基础面试题.html" class="sidebar-link">基础面试题</a></li><li><a href="/面试突击班/多线程与IO.html" class="sidebar-link">多线程与IO</a></li><li><a href="/面试突击班/JVM面试突击班2025.html" class="sidebar-link">JVM面试突击班2025-1</a></li><li><a href="/面试突击班/JVM2024-下.html" class="sidebar-link">JVM2024-下</a></li><li><a href="/面试突击班/JVM2024-上.html" class="sidebar-link">JVM2024-上</a></li><li><a href="/面试突击班/redis2025.html" class="sidebar-link">redis2025-上</a></li><li><a href="/面试突击班/redis2024-下.html" class="sidebar-link">redis2024-下</a></li><li><a href="/面试突击班/redis2024-上.html" class="sidebar-link">redis2024-上</a></li><li><a href="/面试突击班/Mysql.html" class="sidebar-link">Mysql</a></li><li><a href="/面试突击班/Mysql2024-下.html" class="sidebar-link">MySQL2024-下</a></li><li><a href="/面试突击班/并发编程2025.html" class="active sidebar-link">并发编程-2025</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#并发编程-2025" class="sidebar-link">并发编程-2025</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#_1、sleep、wait的区别-猫眼" class="sidebar-link">1、sleep、wait的区别（猫眼）</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#_2、wait和notify做什么的-为什么他们是object类中的方法-猫眼" class="sidebar-link">2、wait和notify做什么的，为什么他们是Object类中的方法（猫眼）</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#_3、线程安全的保证-致宇宁波" class="sidebar-link">3、线程安全的保证（致宇宁波）</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#_4、自旋锁、cas、乐观悲观-国人通、致宇宁波、仕硕科技、航天低空、爱奇艺" class="sidebar-link">4、自旋锁、CAS、乐观悲观（国人通、致宇宁波、仕硕科技、航天低空、爱奇艺）</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#_5、aqs-滴滴司乘、仕硕科技、元保" class="sidebar-link">5、AQS（滴滴司乘、仕硕科技、元保）</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#_6、sync和lock的区别-滴滴司乘" class="sidebar-link">6、sync和lock的区别（滴滴司乘）</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#_7、lock-trylock-lockinterruptibly的区别-滴滴司乘" class="sidebar-link">7、lock，tryLock，lockInterruptibly的区别（滴滴司乘）</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#_8、synchronized、锁升级-致宇宁波" class="sidebar-link">8、synchronized、锁升级（致宇宁波）</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#_9、jmm-仕硕科技" class="sidebar-link">9、JMM（仕硕科技）</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#_10、volatile的作用-爱奇艺" class="sidebar-link">10、volatile的作用（爱奇艺）</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#并发编程-2025-下" class="sidebar-link">并发编程-2025-（下）</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#_1、juc包下有哪些常见的工具-国人通、宝马" class="sidebar-link">1、JUC包下有哪些常见的工具（国人通、宝马）</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#_2、项目中哪里用到了多线程-众安保险、鸿盛天极" class="sidebar-link">2、项目中哪里用到了多线程（众安保险、鸿盛天极）</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#_3、线程池参数-滴滴司乘、仕硕科技、元保" class="sidebar-link">3、线程池参数（滴滴司乘、仕硕科技、元保）</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#_4、提交任务到线程池的细节-仕硕科技-中关村科金" class="sidebar-link">4、提交任务到线程池的细节（仕硕科技，中关村科金）</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#_5-1、核心线程1个正在工作-最大线程2个-来任务想直接创建非核心线程-不想放到等待队列" class="sidebar-link">5.1、核心线程1个正在工作，最大线程2个，来任务想直接创建非核心线程（不想放到等待队列）</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#_5-2-后续再来任务-在进入队列-问怎么做-飞书" class="sidebar-link">5.2 后续再来任务，在进入队列，问怎么做？（飞书）</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#_6、任务来了可以再有选择的优先创建线程或者扔到等待队列-飞书" class="sidebar-link">6、任务来了可以再有选择的优先创建线程或者扔到等待队列（飞书）</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#_7、工作线程在执行任务时-抛出了异常-工作线程会被销毁嘛-中关村科金" class="sidebar-link">7、工作线程在执行任务时，抛出了异常，工作线程会被销毁嘛？（中关村科金）</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#_8、线程池有哪些队列。-国人通" class="sidebar-link">8、线程池有哪些队列。（国人通）</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#并发编程场景解决方案面试题2025" class="sidebar-link">并发编程场景解决方案面试题2025</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#_1、设计一个异步任务执行框架-如何利用多线程来执行耗时的任务-并在任务完成后通知主线程-美团地图" class="sidebar-link">1、设计一个异步任务执行框架，如何利用多线程来执行耗时的任务，并在任务完成后通知主线程（美团地图）</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#_2、设计一个后台任务调度系统-如何利用多线程来并行执行多个定时任务-提高任务的处理效率-滴滴司乘" class="sidebar-link">2、设计一个后台任务调度系统，如何利用多线程来并行执行多个定时任务，提高任务的处理效率（滴滴司乘）</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#第二题当时的问题解决" class="sidebar-link">第二题当时的问题解决</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#_3、描述如何使用多线程来处理大数据集-例如在数据分析应用中-将数据拆分成多个部分并行处理-58同城" class="sidebar-link">3、描述如何使用多线程来处理大数据集，例如在数据分析应用中，将数据拆分成多个部分并行处理（58同城）</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#_4、描述如何实现一个网络爬虫-利用多线程并行抓取多个网页-提高数据抓取的效率-百度ai" class="sidebar-link">4、描述如何实现一个网络爬虫，利用多线程并行抓取多个网页，提高数据抓取的效率（百度AI）</a></li><li class="sidebar-sub-header"><a href="/面试突击班/并发编程2025.html#_5、描述如何在java应用中使用多线程执行数据库的批量插入或更新操作-以提高数据库的写入效率-猫眼" class="sidebar-link">5、描述如何在Java应用中使用多线程执行数据库的批量插入或更新操作，以提高数据库的写入效率（猫眼）</a></li></ul></li><li><a href="/面试突击班/并发编程2024.html" class="sidebar-link">并发编程2024-1</a></li><li><a href="/面试突击班/Spring-2024下.html" class="sidebar-link">Spring-2024下</a></li><li><a href="/面试突击班/Spring-2024上.html" class="sidebar-link">Spring-2024上</a></li><li><a href="/面试突击班/MQ2025上.html" class="sidebar-link">MQ-2025上</a></li><li><a href="/面试突击班/MQ2024下.html" class="sidebar-link">MQ-2024下</a></li><li><a href="/面试突击班/MQ2024上.html" class="sidebar-link">MQ-2024上</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="并发编程-2025"><a href="#并发编程-2025" class="header-anchor">#</a> 并发编程-2025</h2> <p><strong>所有问题都是不会就回家等通知！！！！！！！！</strong></p> <h2 id="_1、sleep、wait的区别-猫眼"><a href="#_1、sleep、wait的区别-猫眼" class="header-anchor">#</a> 1、sleep、wait的区别（猫眼）</h2> <blockquote><p>这个是一个常识性的问题，一般是基于他引出更多的问题</p> <p>从方法和功能的角度来聊。</p> <ul><li>sleep是Thread中的静态方法，目的是让执行这个方法的线程进入TIMED_WAITING，WAITING状态。</li> <li>wait是Object中的一个普通方法，目的是让持有锁的线程释放锁资源并且进入到TIMED_WAITING，WAITING状态</li></ul> <p>sleep是由线程执行Thread.sleep方法，而wait是由持有锁的线程执行锁对象.wait方法。</p> <p>sleep在进入阻塞状态时，不会释放锁资源（跟锁没关系）。 wait在进入阻塞状态时，会释放锁资源。</p></blockquote> <h2 id="_2、wait和notify做什么的-为什么他们是object类中的方法-猫眼"><a href="#_2、wait和notify做什么的-为什么他们是object类中的方法-猫眼" class="header-anchor">#</a> 2、wait和notify做什么的，为什么他们是Object类中的方法（猫眼）</h2> <blockquote><p>首先wait和notify都是和synchronized挂钩的。</p> <p>第一点小扫盲一下synchronized一些小原理~</p> <p><img src="/assets/img/31bcba9c67aa4a8d83966d36f8641f8a.091e9e20.png" alt="image.png"></p> <p>wait方法就是将持有锁的线程，封装为ObjectWaiter，扔到WaitSet中等待被唤醒。</p> <p>notify方法就是将WaitSet中等待被唤醒的线程扔到EntryList中等待竞争锁资源（被唤醒的线程，需要重新等待竞争锁资源）。notifyAll就是将WaitSet中等待池的所有线程都唤醒，都扔到EntryList中。</p> <hr> <p><strong>为什么他们是Object类中的方法？</strong></p> <p>因为咱们在执行wait和notify或者是notifyAll方法时，本质都是在操作对象锁中的ObjectMonitor里提供的很多数据结构和一些API，这里需要对象锁中的ObjectMonitor的API，你不持有锁，没法调用它里面的API。。</p></blockquote> <h2 id="_3、线程安全的保证-致宇宁波"><a href="#_3、线程安全的保证-致宇宁波" class="header-anchor">#</a> 3、线程安全的保证（致宇宁波）</h2> <blockquote><p>这个是一个常识性的问题，一般是基于他引出更多锁</p> <p>线程不安全的原因是多个线程并发操作临界资源导致的问题。</p> <p>1、可以从临界资源方面规避，每个线程自己玩自己的数据就可以了，就不存在多线程并发操作的问题了，比如HashMap这种集合，就应当在方法内部去构建，不要构建成共享资源。</p> <p>2、如果场景就是存在多个线程并发操作临界资源，那想保证线程安全，就需要用到锁。</p> <p>Ps：后面就要引出你最想聊的。Java中得几个常见锁，<strong>CAS、synchronized、ReentrantLock、ReentrantReadWriteLock，StampedLock。（Redis分布式锁，最好聊Redisson）</strong></p> <p><strong>3、如果你项目中涉及到了用锁的点，你就可以展开你的项目去聊。</strong></p></blockquote> <h2 id="_4、自旋锁、cas、乐观悲观-国人通、致宇宁波、仕硕科技、航天低空、爱奇艺"><a href="#_4、自旋锁、cas、乐观悲观-国人通、致宇宁波、仕硕科技、航天低空、爱奇艺" class="header-anchor">#</a> 4、自旋锁、CAS、乐观悲观（国人通、致宇宁波、仕硕科技、航天低空、爱奇艺）</h2> <blockquote><p>当问到了乐观锁和悲观锁的时候，就从锁分类维度的展开聊。</p> <p>乐观悲观：</p> <ul><li>乐观：认为没有并发情况，直接动手！看成功失败！不阻塞线程。CAS</li> <li>悲观：认为必然有并发，先尝试拿锁资源，再动手，拿不到锁资源就阻塞线程。lock，synchronized</li></ul> <p>互斥共享：</p> <ul><li>互斥：只能有一个线程同时持有一把锁。 synchronized，lock</li> <li>共享：同一时间，可以有多个线程持有一把锁，一般是针对读写锁的实现。ReentrantReadWriteLock，StampedLock。</li></ul> <p>重入非重入：同一个线程持有一把锁的时候，再次竞争这个锁资源，是可以直接获取的。</p> <p><strong>Ps：非重入锁在Java中只有线程池里的Worker对象是非重入的，但是这个Worker的锁不对外提供，是内部的一个机制。</strong></p> <p>公平非公平：是否存在插队的情况，synchronized和lock锁默认都是非公平锁（其实不是真插队，是上来直接抢，抢到走人，抢不到还是乖乖的去排队）。公平锁就是锁被持有，或者有排队的，就直接排到最后面，不抢。</p> <p><strong>Ps：公平锁的实现在构建ReentrantLock对象时，有参构造里传入true即可。</strong></p> <hr> <p><strong>细聊一下自旋锁和CAS？</strong></p> <p><strong>自旋锁这个名词是synchronized内部的。在synchronized中有个轻量级锁的概念，他会多次的执行CAS去尝试获取锁资源，而这个多次CAS就被称为自旋锁。</strong></p> <p>而CAS本质在Java中是一个方法，Unsafe类中的一个native方法。</p> <p>本质是在oldValue和当前值一样的情况下，将olaValue修改为newValue</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// CAS的本质是针对某个对象中的某个属性从oldValue修改为newValue</span>
var1：哪个对象？
var2：属性在这个对象中的偏移量。
var4：oldValue
var5：newValue
<span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token class-name">Object</span> var4<span class="token punctuation">,</span> <span class="token class-name">Object</span> var5<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>CAS只是在修改一个属性时，确保线程安全，无法保证一段代码的线程安全。</p> <p>同时compareAndSwapObject方法是native修饰的，他的本质是利用的CPU的指令来实现的，cmpxchg。</p> <p><strong>Compare And Exchange（cmpxchg）</strong></p> <hr> <p><strong>CAS的几个问题：</strong></p> <ul><li>ABA：在多线程并发的情况下，要修改的值，本来不符合预期，但是修改的时候，因为其他线程的操作，导致符合预期了，就直接修改了。不是咱想要的。解决的方式也很简单，额外加一个版本好即可。而且Java中已经提供了对应的工具类，AtomicStampedReference，提供了除了值之外的额外的版本号可以指定。
<strong>Ps：ABA不一定是问题，就好比你的银行卡，你花了10块，又存了10块，之前钱没问题，就是ok的。具体看业务，比如刚才举例的二手车问题。</strong></li> <li>自旋次数过多：因为CAS不会挂起线程，可以一直执行，比如AtomicInteger，他的底层是一个do-while循环，一直CAS，直到成功为止，如果一直不成功，就会一直占用CPU资源，一直执行。。</li> <li>无法保证一段代码的原子性，想保证得封装，不过Java封装好了，synchronized，lock锁都是基于CAS实现的。</li></ul></blockquote> <h2 id="_5、aqs-滴滴司乘、仕硕科技、元保"><a href="#_5、aqs-滴滴司乘、仕硕科技、元保" class="header-anchor">#</a> 5、AQS（滴滴司乘、仕硕科技、元保）</h2> <blockquote><p>1、解释一下什么是AQS（引出其他的JUC下的工具）</p> <p>AQS的本质就JUC包下的一个抽象类</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre></div><p>AQS就是一个基础类，并没有具体的并发功能实现，是JUC包下的大多数的工具都是基于AQS实现的，比如：ThreadPoolExecutor，ReentrantLock，CountDownLatch，Semaphore……</p> <p>2、聊一下AQS中的三个核心内容</p> <ul><li>state属性， <strong>由volatile修饰，基于CAS修改</strong> ，他是作为资源的int类型属性，比如CountDownLatch中他就是计数器中的内个数，ReentrantLock中他就是竞争锁修改的内个属性。。。。</li> <li>同步队列（双向链表），拿不到资源的线程需要排队等，就在这个同步队列里等。<strong>（类比EntryList）</strong></li> <li>单向链表，一般是跟锁有关的，当持有锁的线程，执行了AQS提供的Condition里的await时，要扔到这个单向链表中挂起，等待被signal唤醒。<strong>（类比WaitSet）</strong></li></ul></blockquote> <h2 id="_6、sync和lock的区别-滴滴司乘"><a href="#_6、sync和lock的区别-滴滴司乘" class="header-anchor">#</a> 6、sync和lock的区别（滴滴司乘）</h2> <blockquote><p>1、<s>单词不一样</s>（面试别说。。）</p> <p>2、synchronized是关键字，lock是一个类。</p> <p>3、synchronized就同步方法，同步代码块的使用方式，lock需要调用API。</p> <p>4、从性能的维度来说，他俩几乎没有什么区别。（在JDK1.6synchronized优化之后）</p> <p>5、从功能丰富的角度来说，lock更灵活，功能更丰富。</p> <p>6、比如synchronized会自动释放锁资源，lock锁必须确保unlock要执行，最好扔fianlly里。</p> <p>7、synchronized竞争锁是基于C++的方式，利用CAS修改owner竞争锁，ReentrantLock是基于CAS修改state属性，从0改为1。</p> <p><strong>Ps：synchronized中的偏向锁在JDK15被废弃，20中被完全移除了，因为偏向锁撤销需要等待安全点，很耗时，他不但没法优化，反而会导致一定的性能下降，so，在JDK15被干掉了。。。</strong></p> <p>…………</p></blockquote> <h2 id="_7、lock-trylock-lockinterruptibly的区别-滴滴司乘"><a href="#_7、lock-trylock-lockinterruptibly的区别-滴滴司乘" class="header-anchor">#</a> 7、lock，tryLock，lockInterruptibly的区别（滴滴司乘）</h2> <blockquote><p>这几个方法都是ReentrantLock获取锁的方法。。。。</p> <p>lock：拿不到锁直接排队，即便排队时期被中断了（interrupt），依然会继续排队，死等，拿不到锁，就不走了！等到拿道锁，确认是否被中断过，如果中断过，就保留中断标记位。</p> <p>tryLock()：浅尝一下，就抢一次，抢到拿锁走人返回true，抢不到，返回false</p> <p>tryLock(timeout,unit)：浅尝timeout.unit时间，最多等待timeout.unit时间，拿到锁返回true，反之false。并且在等待过程中，如果被中断，会抛出InterruptedException。</p> <p>lockInterruptibly：拿不到锁直接排队，要么拿锁走人，要么被中断抛出InterruptedException。</p></blockquote> <h2 id="_8、synchronized、锁升级-致宇宁波"><a href="#_8、synchronized、锁升级-致宇宁波" class="header-anchor">#</a> 8、synchronized、锁升级（致宇宁波）</h2> <blockquote><p>synchronized常问就几个，锁膨胀（锁粗化）、锁消除、锁升级，基本就这些问题，你如果想深入的去聊synchronized，卷一波，</p> <p><strong>锁膨胀：</strong> 如果设计到了循环内加锁，JIT可能会将加锁的代码膨胀到循环外，避免频繁的加锁，释放锁浪费资源。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 膨胀</span>
<span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>锁消除：</strong> 在没有锁竞争的时候，你加个synchronized，跟没加一样。（看JIT）</p> <p><strong>锁升级：</strong></p> <ul><li>无锁：在偏向锁延迟中，new出来的对象都是无锁状态。  （没有线程竞争呢还。）</li> <li>匿名偏向锁：在偏向锁延迟之后，new出来的对象都是匿名偏向锁。  （没有线程竞争呢还。）</li> <li>偏向锁：短时间内，就一个线程反复的获取这个锁，没有竞争，此时这个锁的状态就是偏向锁。</li> <li>轻量级锁：在偏向锁时，出现了锁竞争，此时就会升级为轻量级锁，默认会执行10次CAS，去尝试获取锁资源。10次会变化，因为用的是自适应自旋锁，如果上次自旋成功，下次自旋次数会增加。</li> <li>重量级锁：当轻量级锁的状态自旋后，没拿到锁资源，升级为重量级锁，重量级锁的状态下依然会执行多次CAS，拿不到锁资源才会挂起线程。</li></ul></blockquote> <h2 id="_9、jmm-仕硕科技"><a href="#_9、jmm-仕硕科技" class="header-anchor">#</a> 9、JMM（仕硕科技）</h2> <blockquote><p><strong>每次突击班，我基本都会说JMM，而且每次都要说一句。</strong></p> <p><strong>别这么写技术栈： 熟练掌握JVM，JMM，了解GC回收。。。  JMM属于并发编程，别放这。。。。。</strong></p> <p><strong>如果面试被问到了Java的内存模型，你要聊JMM，如果是问了Java的内存结构或者是JVM的内存模型，你去聊堆、栈、方法区。。</strong></p> <p><strong>因为咱们程序是由线程去执行指令的，线程是由CPU去调度的。但是CPU由于厂商不同，型号不同，在做一些并发操作时，他去解决原子性，可见性，有序性时，他们提供的指令或者是解决方案可能各有不同，JMM的目的，就是为了解决这个硬件，甚至包括不同的操作系统带来的一些差异化的影响。从而实现Java的跨平台的并发编程能力。</strong></p> <p>比如有序性，在不用的CPU型号中，解决问题的方式就不一样，JMM就可以去调用不同型号CPU的解决方式。</p> <p><img src="/assets/img/8662bb9d211245c2b53a3ef2bf08f66d.7d38a499.png" alt="image.png"></p></blockquote> <h2 id="_10、volatile的作用-爱奇艺"><a href="#_10、volatile的作用-爱奇艺" class="header-anchor">#</a> 10、volatile的作用（爱奇艺）</h2> <blockquote><p>volatile只能解决可见和有序，他跟原子性没关系，原子性最底层的基本就是CAS了。</p> <p><strong>1、可见性问题怎么发生的。</strong></p> <p>因为CPU在调度线程时，为了加快处理速度，会将一些从JVM中获取的数据扔到CPU缓存中，下次操作就直接从CPU缓存中拿，直接使用。但是CPU是多核的，L1和L2在多个CPU核心之间是相互隔离开的。</p> <p>所以多个内核之间的高速缓存会存在数据不一致的问题。所以CPU自身也有解决方案，一般CPU的厂商会基于MESI协议，实现多个高速缓存之间的一致性。但是因为CPU的核心是性能，MESI会影响性能。</p> <p>So，很多厂商就对MESI多了很多的优化，比如Store Buffer ，InvalidateQueue，这些都会导致MESI协议会延迟触发，导致虽然有这个机制，但是依然存在数据不一致的问题。</p> <p><strong>2、volatile怎么解决的可见性</strong></p> <p>volatile在底层针对被修饰的属性操作时，会追加 <strong>lock前缀指令</strong> ，这个指令会强制触发MESI，绕过那些所谓的优化，保证一致性。</p> <p><strong>3、有序性怎么发生的。</strong></p> <p>有序性其实就是  <strong>禁止指令重排</strong>  ，指令重排有俩地方会做，一个JIT，一个就是CPU。</p> <p>指令重排会在确保最终结果没啥变化的前提下，去将指令的前后顺序做一个变化，最经典的就是单例模式中的懒汉机制存在的问题。 比如new对象过程的三个步骤的顺序被调整。</p> <ul><li>1、申请内存空间。 2、初始化属性。 3、地址引用赋值。</li> <li>重排为</li> <li>1、申请内存空间。2、地址引赋值。3、初始化属性。</li></ul> <p>问题就是，并发情况下，可能会拿到一个还没初始化属性的对象去操作，容易NPE。</p> <p>So，单例模式的懒汉机制如果使用DCL保证线程安全，同时还要给对象的引用追加volatile，确保有序性，不会造成上述的问题。</p> <p><strong>4、volatile怎么解决的有序性。</strong></p> <ul><li>从指令层面上看，是利用内存屏障解决的。</li> <li>内存屏障会被不同的CPU解析成不同的函数或者指令。</li> <li>在×86的CPU中，会将Store Load Barrier，转换为mfence的函数</li> <li>在追踪函数后，依然会看到   <strong>lock前缀指令</strong> 。</li></ul></blockquote> <h2 id="并发编程-2025-下"><a href="#并发编程-2025-下" class="header-anchor">#</a> 并发编程-2025-（下）</h2> <h2 id="_1、juc包下有哪些常见的工具-国人通、宝马"><a href="#_1、juc包下有哪些常见的工具-国人通、宝马" class="header-anchor">#</a> 1、JUC包下有哪些常见的工具（国人通、宝马）</h2> <blockquote><p>这个问题本身没啥营养，他的目的依然是引出后续要聊的一些内容。。。</p> <p>贴近项目，一般比较多的套路就是CountDownLatch + ThreadPoolExecutor去实现一些并行操作去提升业务的一些性能。</p> <p>AQS、ReentrantLock，Semaphore，CyclicBarrier，ReentrantReadWriteLock。</p> <p>………………</p> <p>老师，我业务用到线程池。</p> <p>记住，没有也得有，自己run！！！！！！</p></blockquote> <h2 id="_2、项目中哪里用到了多线程-众安保险、鸿盛天极"><a href="#_2、项目中哪里用到了多线程-众安保险、鸿盛天极" class="header-anchor">#</a> 2、项目中哪里用到了多线程（众安保险、鸿盛天极）</h2> <blockquote><p>很多同学在开发的过程中，基本就没玩过优化相关的东西，一切都是业务实现为核心，只要功能没问题，测试能通过，完事！！！</p> <p>同学们应当用过@Async，@Scheduled，这都是SpringBoot提供一个很基本的注解。</p> <p>一个实现异步方法，一个实现定时任务。</p> <p>先聊@Async：</p> <ul><li><p>Async注解默认使用的线程池的线程只有8个，最大并行也就是8，如果并发很大，可能会导致异步的任务处理的时间很慢，甚至任务太多，都有可能OOM。、</p></li> <li><p>问题出现了，解决方案也就简单了，可以自己去配置@Async使用的线程池的具体细节。</p> <div class="language- extra-class"><pre class="language-text"><code>@Configuration
public class AsyncConfig implements AsyncConfigurer {
  
    @Override
    public Executor getAsyncExecutor() {
        // 自己在这去创建线程池，解决现在@Async注解存在的问题。。
        return AsyncConfigurer.super.getAsyncExecutor();
    }
}
</code></pre></div></li></ul> <p>再聊@Scheduled：</p> <ul><li><p>在使用@Scheduled执行定时任务的时候，发现指定了多个任务的执行周期是一致的，但是同时只有一个任务在执行，其他任务需要等待当前任务执行完毕后才能执行。</p></li> <li><p>问题很简单，依然是默认线程池的问题，默认的@Scheduled注解提供的线程池就一个核心线程，理论上他同一时间只能执行一个任务。</p></li> <li><p>排查Spring默认提供的线程池，他默认最大线程数，是1个，导致任务只能并行走一个。自己设置即可</p> <div class="language- extra-class"><pre class="language-text"><code>@Configuration
public class TaskConfig  implements SchedulingConfigurer {
    @Override
    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
        // 自己提供即可。。。
    }
}
</code></pre></div></li></ul> <p>除此之前，你项目上线前，Tomcat线程池也需要配置把。。。比如用到了MQ，你MQ中的消费者，如果不设置并行情况，比如RabbitMQ，默认就一个线程作为线程池从Queue中拉取消息消费。</p> <p><strong>除此之外，之前一个学员面试中，面试官特意强调了，别说框架中涉及到的，你有自己去new 线程池去处理一些业务嘛？？（原问题是设计模式）</strong></p> <p>此时就要润色了。。。。。可以看看这个。核心方向就内个几个</p> <ul><li>多次查询数据库或者三方服务的业务，可以基于线程池并行去查询三方以及数据库，减少网络IO带来的时间成本。。。</li> <li>比较大的数据，或者文件之类的东西，单个线程处理速度太慢了，可以将这种文件或者数据做好合理的切分，让多个线程并行去处理，最终汇总即可。</li></ul> <p><img src="/assets/img/7a0aeacc48ef4a1c977bef1f33db886c.9aa4affa.png" alt="image.png"></p></blockquote> <h2 id="_3、线程池参数-滴滴司乘、仕硕科技、元保"><a href="#_3、线程池参数-滴滴司乘、仕硕科技、元保" class="header-anchor">#</a> 3、线程池参数（滴滴司乘、仕硕科技、元保）</h2> <blockquote><p>这个不是面试题，这个是常识。回答的时候，卡壳都不行！</p> <p>这个不是让你背的，是必须理解的。</p> <p>核心线程数</p> <p>工作队列</p> <p>最大线程数</p> <p>拒绝策略</p> <p>最大空闲时间</p> <p>空闲时间单位</p> <p>线程工厂</p></blockquote> <h2 id="_4、提交任务到线程池的细节-仕硕科技-中关村科金"><a href="#_4、提交任务到线程池的细节-仕硕科技-中关村科金" class="header-anchor">#</a> 4、提交任务到线程池的细节（仕硕科技，中关村科金）</h2> <blockquote><p>任务投递过来后的基本流程：</p> <ul><li>尝试创建核心线程去处理任务。</li> <li>核心线程数达到了要求，就将任务扔到工作队列。 （有后续操作，任务饥饿问题，<strong>如果出现队列有任务，但是没有工作线程的情况</strong>，他会创建一个非核心线程去处理队列的任务）</li> <li>工作队列放慢了，就会创建非核心线程去处理任务。</li> <li>工作线程数，达到最大线程数了，执行拒绝策略。</li></ul> <p>线程池里区分核心与非核心线程吗？  <strong>创建的时候，区分，干上活之后，不区分。</strong></p> <p>线程池里关心工作线程是否空闲吗？  <strong>不关心，他只关心数！、</strong></p> <p><strong>1、Java线程池，5核心、10最大、10队列，第6个任务来了是什么状态？</strong></p> <p><strong>2、如果在第6个任务过来的时候，5个核心线程都已经空闲了呢？</strong></p> <p><strong>3、第16个任务来了怎么处理？</strong></p> <p><strong>4、第16个任务来了的时候，要是有核心线程空闲了呢？</strong></p> <p><strong>5、队列满了以后执行队列的任务是从队列头 or 队尾取？</strong></p> <p><strong>为什么核心满了，不去创建最大线程数，而是扔到队列后，才考虑创建非核心线程？</strong></p> <ul><li>将任务扔到队列的目的是为了缓冲，由现在的线程去处理任务，如果上来直接额外创建非核心线程，那核心跟非核心的意义就不大了。浪费资源，多线程了。。。</li></ul> <p><strong>为什么非核心线程创建的时候，要优先执行投递过来的任务，而不是执行队列中任务？</strong></p> <ul><li>投递任务到线程池的目的为了走异步，更快的处理后续的业务，上述这个方式可以让异步的响应速度很快。
<ul><li>如果是先处理队列的任务，那就需要先完成线程的创建，并且启动，然后从工作队列中获取任务，然后你的新任务才能投递到工作队列。</li> <li>反之，如果是直接由非核心线程处理， 执行到线程的创建和启动就结束了。</li></ul></li></ul></blockquote> <h2 id="_5-1、核心线程1个正在工作-最大线程2个-来任务想直接创建非核心线程-不想放到等待队列"><a href="#_5-1、核心线程1个正在工作-最大线程2个-来任务想直接创建非核心线程-不想放到等待队列" class="header-anchor">#</a> 5.1、核心线程1个正在工作，最大线程2个，来任务想直接创建非核心线程（不想放到等待队列）</h2> <blockquote><p>1、队列长度为0即可。</p> <p>2、队列可以使用SynchronousQueue。</p></blockquote> <h2 id="_5-2-后续再来任务-在进入队列-问怎么做-飞书"><a href="#_5-2-后续再来任务-在进入队列-问怎么做-飞书" class="header-anchor">#</a> 5.2 后续再来任务，在进入队列，问怎么做？（飞书）</h2> <blockquote><p>先从执行顺序来说，按照前面的参数特点，这次的任务只能走拒绝策略，可以在拒绝策略的位置，依然基于SynchronousQueue，利用put，一直等。（但是这样会影响到投递任务的线程。。。）</p> <p>另外一个解决方式，可以在投递第三个任务之前，修改队列的长度。</p> <ul><li>可以获取到队列的引用，直接修改他的引用即可，但是，发现workQueue的引用是final修饰的，方案不行。  ×</li> <li>咱们又去考虑，直接使用LinkedBlockingQueue，这哥们是链表结构，动态修改他的长度把，不行，虽然count是Atomic类型，但是CAPACITY最大值是final修饰的也不让改。  ×</li> <li>想通过修改队列长度实现，就得自己实现一个阻塞队列，可以动态修改长度的。。</li></ul></blockquote> <h2 id="_6、任务来了可以再有选择的优先创建线程或者扔到等待队列-飞书"><a href="#_6、任务来了可以再有选择的优先创建线程或者扔到等待队列-飞书" class="header-anchor">#</a> 6、任务来了可以再有选择的优先创建线程或者扔到等待队列（飞书）</h2> <blockquote><p>基于原来的execute的逻辑，必然没法实现这个逻辑，咱们能做到，只有重新execute内部的一些机制，或者是换一个投递任务的方法，自己在内部来一波逻辑。。。</p> <p>1、任务要区分优先级到哪，你的每个任务要有一个标识。确定优先级。可以创建一个抽象类，实现Runnable，设置好一个优先级属性</p> <p>2、需要构建一个类，去继承ThreadPoolExecutor，然后去自己声明一个投递任务的方法。</p> <ul><li>如果队列优先，可以直接基于super获取到工作队列，然后offer或者put到工作队列中。</li> <li>如果要创建线程去处理，可以直接走execute方法。（理想状态下，是调用addWorker，但是线程池本身addWorker是private的，不允许外部调用）</li></ul> <p>如果再问，队列扔到工作线程后，任务饥饿怎么办，如果线程优先的任务执行exeute，核心跳过后放到工作队列怎么办？</p> <p>那就不用ThreadPoolExecutor了，他不满足现在的要求，自己实现一个线程池！</p></blockquote> <h2 id="_7、工作线程在执行任务时-抛出了异常-工作线程会被销毁嘛-中关村科金"><a href="#_7、工作线程在执行任务时-抛出了异常-工作线程会被销毁嘛-中关村科金" class="header-anchor">#</a> 7、工作线程在执行任务时，抛出了异常，工作线程会被销毁嘛？（中关村科金）</h2> <blockquote><p>给线程池投递任务的方式有几种？</p> <ul><li>execute，投递Runnable的任务</li> <li>submit，投递Callable的任务（也可以投递Runnable）</li></ul> <p>submit本质还是基于execute投递的任务，但是在投递任务前，将任务封装为了RunnableFuture的类，可以看做是FutureTask……</p> <p>execute投递的Runnable任务，异常会直接抛出，基于runWorker方法抛出，抛到Worker类的run方法，run方法会异常结束，run方法结束，Worker线程销毁。</p> <p>submit投递的任务，当出现异常时，Future会将任务的异常保留在Future内部，不会抛出，在你基于Future去get的时候，异常才会catch到。异常是保留的FutureTask里面的outcome属性中。。。</p></blockquote> <h2 id="_8、线程池有哪些队列。-国人通"><a href="#_8、线程池有哪些队列。-国人通" class="header-anchor">#</a> 8、线程池有哪些队列。（国人通）</h2> <blockquote><p>首先线程池要求提供的是阻塞队列，也就是BlockingQueue的实现。</p> <p>这里有很多，比如</p> <ul><li><strong>ArrayBlockingQueue：底层数组，定长</strong></li> <li><strong>LinkedBlockingQueue：底层链表，也可以定长，也可以不定长</strong></li> <li>PriorityBlockingQueue：底层是数组实现的二叉堆，一般用于定时处理。</li> <li>SynchronousQueue：不存储任务，直接以匹配的方式。</li> <li>DelayQueue：底层也是二叉堆，是PriorityBlockingQueue的二次封装。</li></ul> <p><strong>一般咱们常用的就是ArrayBlockingQueue和LinkedBlockingQueue，而我们要求就使用LinkedBlockingQueue，因为线程池中的队列存放的任务会进进出出，增删多，那链表结构更合适。</strong></p> <p><strong>并且LinkedBlockingQueue是生产者和消费者各吃一把锁，互不影响，总之性能相对好一些。</strong></p></blockquote> <h2 id="并发编程场景解决方案面试题2025"><a href="#并发编程场景解决方案面试题2025" class="header-anchor">#</a> <strong>并发编程场景解决方案面试题</strong>2025</h2> <h2 id="_1、设计一个异步任务执行框架-如何利用多线程来执行耗时的任务-并在任务完成后通知主线程-美团地图"><a href="#_1、设计一个异步任务执行框架-如何利用多线程来执行耗时的任务-并在任务完成后通知主线程-美团地图" class="header-anchor">#</a> 1、设计一个异步任务执行框架，如何利用多线程来执行耗时的任务，并在任务完成后通知主线程（美团地图）</h2> <blockquote><p>问的这个东西，其实Java中自带的工具已经实现了。利用CompletableFuture就可以实现这个效果，可以点一嘴CompletableFuture的一些API，证明你会。</p> <p>比如CompletableFuture.supplyAsync知道好具体要执行的任务，然后在后续，追加一个thenApplyAsync，等任务完成后，执行thenApplyAsync的回调。</p> <p>如果舍弃掉CompletableFuture，自己主动的去实现一个异步任务的执行框架，需要考虑哪些事情，怎么去落地实现。</p> <p>1、优先构建好Java提供的线程池，ThreadPoolExecutor，用于多线程执行任务。</p> <p>2、要求主动通知主线程，需要一个回调的函数，不能让主线程自己去get。针对回调函数，至少要提供成功与失败的方法。 onComplete，onError。</p> <p>3、提供一个提交任务的方法，这个方法至少两个参数，一个是具体的任务Runnable，一个回调Callback。也可以提供一个执行Callable的提交任务的方法。</p> <p>4、比如任务执行超时后，想要去走超时的回调，onTimeout啥的，直接在提交任务后面去追加。</p> <p>5、比如任务执行一段时间后，要取消，一样可以提供任务的返回结果，让主线能拿到任务并且走cancel。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>example</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 要自己设计的一个异步框架。
 * 1、优先构建好Java提供的线程池，ThreadPoolExecutor，用于多线程执行任务。
 *
 * 2、要求主动通知主线程，需要一个回调的函数，不能让主线程自己去get。针对回调函数，至少要提供成功与失败的方法。 onComplete，onError。
 *
 * 3、提供一个提交任务的方法，这个方法至少两个参数，一个是具体的任务Runnable，一个回调Callback。也可以提供一个执行Callable的提交任务的方法。
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AsyncTaskFramework</span> <span class="token punctuation">{</span>

    <span class="token comment">// 偷个懒，基于Executors先构建一个。。。</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 利用回调的方式，实现任务完成后，通知主线程。</span>
    <span class="token keyword">private</span> <span class="token keyword">interface</span> <span class="token class-name">Callback</span><span class="token punctuation">{</span>
        <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token class-name">Object</span> result<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">onError</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">onTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 执行Runnable，提供callback的机制。
     * @param task
     * @param callback
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">submitTask</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">,</span> <span class="token class-name">Callback</span> callback<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 提交任务到线程池时，自己写一套业务，确认可以在任务完成后，执行回调</span>
        executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token comment">// 代码执行到这，已经是线程池里的线程在执行了，已经是异步的了。</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 执行任务</span>
                task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 任务执行完毕，没出现异常</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>callback <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    callback<span class="token punctuation">.</span><span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>callback <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    callback<span class="token punctuation">.</span><span class="token function">onError</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 执行Callable，提交callback回调。
     * @param task
     * @param callback
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">submitTask</span><span class="token punctuation">(</span><span class="token class-name">Callable</span> task<span class="token punctuation">,</span> <span class="token class-name">Callback</span> callback<span class="token punctuation">)</span><span class="token punctuation">{</span>
        executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">Object</span> result <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>callback <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    callback<span class="token punctuation">.</span><span class="token function">onComplete</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>callback <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    callback<span class="token punctuation">.</span><span class="token function">onError</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 追加超时的逻辑
     * @param task
     * @param callback
     * @param timeout
     * @param unit
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">submitTask</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">,</span> <span class="token class-name">Callback</span> callback<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>callback <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    callback<span class="token punctuation">.</span><span class="token function">onError</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 判断超时与否</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>timeout<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 成功的逻辑</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>callback <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                callback<span class="token punctuation">.</span><span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">TimeoutException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 超时的逻辑</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>callback <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                callback<span class="token punctuation">.</span><span class="token function">onTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> <span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 异常的逻辑</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>callback <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                callback<span class="token punctuation">.</span><span class="token function">onError</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">AsyncTaskFramework</span> framework <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AsyncTaskFramework</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        framework<span class="token punctuation">.</span><span class="token function">submitTask</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>

            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;异步执行：xxxxx&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;主线程在任务完毕后的回调&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onError</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;任务执行出现异常，通知主线程。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre></div></blockquote> <h2 id="_2、设计一个后台任务调度系统-如何利用多线程来并行执行多个定时任务-提高任务的处理效率-滴滴司乘"><a href="#_2、设计一个后台任务调度系统-如何利用多线程来并行执行多个定时任务-提高任务的处理效率-滴滴司乘" class="header-anchor">#</a> 2、设计一个后台任务调度系统，如何利用多线程来并行执行多个定时任务，提高任务的处理效率（滴滴司乘）</h2> <blockquote><p>后台调度就是一个定时任务的套路。</p> <p>正常咱们很少自己去写这种东西，市面上开源好用的很多，比如单体上Quartz，分布式微服务的环境下，可以上Elastic-Job，XXL-Job等等…………开源定时任务框架非常非常多。。。</p> <p>如果要自己设计的话，可以参考这个开源的框架去自己实现一套，造个轮子。</p> <p>1、首先第一点，自己设计的定时任务框架要支持cron表达式，为了解析cron表达式，可以先导入一个cron-utils的小工具，来解析cron表达式。</p> <p>2、其次构建好Java提供的线程池，ThreadPoolExecutor，用于多线程执行多个定时任务。</p> <p>3、另外，这种基于cron的定时任务，单纯的Runnable没有办法支撑。自己要封装一个任务类。</p> <p>4、因为是定时任务框架，任务要以周期性执行，需要有一个容器可以把任务存储起来，而且涉及到多个任务，所以需要一个线程安全的容器，直接上ConcurrentHashMap。</p> <p>5、可以给当前任务调度框架添加上移除任务和添加任务的功能，暂停任务和启动任务的功能，还有立即执行。</p> <p>6、在定时任务框架开始的时候，就直接要在一个死循环里遍历ConcurrentHashMap中的任务，查询每一个任务是否现在可以执行，可以就直接执行，不可以就拉倒。直到遍历结束，再开启下一次循环~。</p> <p><strong>优先把上述基本的功能实现，先发版，再迭代！！！！</strong></p> <p>7、支持分布式锁，还需要考虑在任务执行前，获取一下Redis的分布式锁，确保就一个服务执行……</p> <p>8、日志，任务失败的重试等等…………</p> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.cronutils<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>cron-utils<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>9.2.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>example</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>cronutils<span class="token punctuation">.</span>model<span class="token punctuation">.</span></span><span class="token class-name">Cron</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>cronutils<span class="token punctuation">.</span>model<span class="token punctuation">.</span></span><span class="token class-name">CronType</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>cronutils<span class="token punctuation">.</span>model<span class="token punctuation">.</span>definition<span class="token punctuation">.</span></span><span class="token class-name">CronDefinition</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>cronutils<span class="token punctuation">.</span>model<span class="token punctuation">.</span>definition<span class="token punctuation">.</span></span><span class="token class-name">CronDefinitionBuilder</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>cronutils<span class="token punctuation">.</span>model<span class="token punctuation">.</span>time<span class="token punctuation">.</span></span><span class="token class-name">ExecutionTime</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>cronutils<span class="token punctuation">.</span>parser<span class="token punctuation">.</span></span><span class="token class-name">CronParser</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span></span><span class="token class-name">Slf4j</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>logging<span class="token punctuation">.</span>log4j<span class="token punctuation">.</span>message<span class="token punctuation">.</span></span><span class="token class-name">AsynchronouslyFormattable</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span></span><span class="token class-name">ZonedDateTime</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Map</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ConcurrentHashMap</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ExecutorService</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Executors</span></span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 异步定时任务框架
 * 1、首先第一点，自己设计的定时任务框架要支持cron表达式，为了解析cron表达式，可以先导入一个cron-util的小工具，来解析cron表达式。
 *
 * 2、其次构建好Java提供的线程池，ThreadPoolExecutor，用于多线程执行多个定时任务。
 *
 * 3、另外，这种基于cron的定时任务，单纯的Runnable没有办法支撑。自己要封装一个任务类。
 *
 * 4、因为是定时任务框架，任务要以周期性执行，需要有一个容器可以把任务存储起来，而且涉及到多个任务，所以需要一个线程安全的容器，直接上ConcurrentHashMap。
 *
 * 5、可以给当前任务调度框架添加上移除任务和添加任务的功能，暂停任务和启动任务的功能，还有立即执行。
 *
 * 6、在定时任务框架开始的时候，就直接要在一个死循环里遍历ConcurrentHashMap中的任务，查询每一个任务是否现在可以执行，可以就直接执行，不可以就拉倒。知道遍历结束。
 */</span>
<span class="token annotation punctuation">@Slf4j</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AsyncScheduleFramework</span> <span class="token punctuation">{</span>
    <span class="token comment">// 偷个懒，基于Executors先构建一个。。。</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 任务需要容器存储，声明CHM</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">ScheduleTask</span><span class="token punctuation">&gt;</span></span> tasks <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ScheduleTask</span><span class="token punctuation">{</span>
        <span class="token comment">// 具体的任务</span>
        <span class="token keyword">private</span> <span class="token class-name">Runnable</span> task<span class="token punctuation">;</span>
        <span class="token comment">// 下次什么时间执行</span>
        <span class="token class-name">ZonedDateTime</span> nextExecuteTime<span class="token punctuation">;</span>
        <span class="token comment">// 计算下次执行时间的对象</span>
        <span class="token class-name">ExecutionTime</span> executionTime<span class="token punctuation">;</span>
        <span class="token comment">// 任务是否开启了可以执行的权限！！</span>
        <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> started <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token comment">// 任务重复执行，第一次确保running为false，才能去执行，在执行前，将running改为true，在执行执行完毕后，再将任务修改为false</span>
        <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> running <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token class-name">ScheduleTask</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">,</span> <span class="token class-name">ZonedDateTime</span> nextExecuteTime<span class="token punctuation">,</span><span class="token class-name">ExecutionTime</span> executionTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>task <span class="token operator">=</span> task<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>nextExecuteTime <span class="token operator">=</span> nextExecuteTime<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>executionTime <span class="token operator">=</span> executionTime<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 计算下次执行的时间。</span>
        <span class="token keyword">void</span> <span class="token function">computeNextExecutionTime</span><span class="token punctuation">(</span><span class="token class-name">ZonedDateTime</span> nextExecuteTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>nextExecuteTime <span class="token operator">=</span> executionTime<span class="token punctuation">.</span><span class="token function">nextExecution</span><span class="token punctuation">(</span>nextExecuteTime<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 添加任务。
     * @param taskName  任务标识，方便后期对任务做启动，停止等操作。
     * @param cronExpression  cron表达式
     * @param task  具体任务
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addTask</span><span class="token punctuation">(</span><span class="token class-name">String</span> taskName<span class="token punctuation">,</span><span class="token class-name">String</span> cronExpression<span class="token punctuation">,</span><span class="token class-name">Runnable</span> task<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 1、 创建解析cron表达式的对象</span>
        <span class="token class-name">CronParser</span> parser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CronParser</span><span class="token punctuation">(</span><span class="token class-name">CronDefinitionBuilder</span><span class="token punctuation">.</span><span class="token function">instanceDefinitionFor</span><span class="token punctuation">(</span><span class="token class-name">CronType</span><span class="token punctuation">.</span><span class="token constant">QUARTZ</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 2、 解析cron表达式</span>
        <span class="token class-name">Cron</span> cron <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>cronExpression<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 3、将解析后的cron表达式转换为ExecutionTime</span>
        <span class="token class-name">ExecutionTime</span> executionTime <span class="token operator">=</span> <span class="token class-name">ExecutionTime</span><span class="token punctuation">.</span><span class="token function">forCron</span><span class="token punctuation">(</span>cron<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 4、基于executionTime获取到下次任务要执行的时间。而且获取到的时间，最好是java.time下的类。</span>
        <span class="token class-name">ZonedDateTime</span> nextExecutionTime <span class="token operator">=</span> executionTime<span class="token punctuation">.</span><span class="token function">nextExecution</span><span class="token punctuation">(</span><span class="token class-name">ZonedDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 5、创建任务对象</span>
        <span class="token class-name">ScheduleTask</span> scheduleTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScheduleTask</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span>nextExecutionTime<span class="token punctuation">,</span>executionTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 6、任务添加到ConcurrentHashMap</span>
        <span class="token comment">// TODO （这里要注意一下，先确保内部没有，咱们再put，忽然会覆盖。）</span>
        tasks<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>taskName<span class="token punctuation">,</span>scheduleTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 任务启动
     * @param taskName
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token class-name">String</span> taskName<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">ScheduleTask</span> scheduleTask <span class="token operator">=</span> tasks<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>taskName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>scheduleTask <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            scheduleTask<span class="token punctuation">.</span>started <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/**
     * 任务暂停
     * @param taskName
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token class-name">String</span> taskName<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">ScheduleTask</span> scheduleTask <span class="token operator">=</span> tasks<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>taskName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>scheduleTask <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            scheduleTask<span class="token punctuation">.</span>started <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">AsyncScheduleFramework</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 在这个框架创建出来的时候，就开始遍历tasks集合，拿到任务就判断是否到了执行时间，并且isRunning为true，才可以执行。</span>
        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">ScheduleTask</span><span class="token punctuation">&gt;</span></span> taskMap <span class="token operator">:</span> tasks<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 获取到具体的任务</span>
                    <span class="token class-name">ScheduleTask</span> task <span class="token operator">=</span> taskMap<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">// 判断执行时间是否满足要求，并且isRunning是否为true</span>
                    <span class="token keyword">if</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span>nextExecuteTime<span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span><span class="token class-name">ZonedDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> task<span class="token punctuation">.</span>started <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>task<span class="token punctuation">.</span>running<span class="token punctuation">)</span><span class="token punctuation">{</span>
                        <span class="token comment">// TODO   获取一波Redis分布式锁的资源，key就可以前缀加任务名称，拿到锁的，才能执行后面的代码。拿锁失败的，就直接计算下次执行的时间</span>
                        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;各种日志，当前服务的标识，具体的任务名是啥，等等……&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token comment">// 将running设置true，代表要开始执行了</span>
                        task<span class="token punctuation">.</span>running <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                        <span class="token comment">// 执行时间到了，并且isRunning为true，代表可以执行。</span>
                        executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
                            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                                <span class="token comment">// 执行任务</span>
                                task<span class="token punctuation">.</span>task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
                                <span class="token comment">// TODO  重试，还是做其他的操作~~~</span>
                            <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>
                                <span class="token comment">// 计算任务下次执行的时间</span>
                                task<span class="token punctuation">.</span><span class="token function">computeNextExecutionTime</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span>nextExecuteTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                task<span class="token punctuation">.</span>running <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token comment">// 现在设计的ConcurrentHashMap作为容器，就是会存在比较大的时间误差，想误差小，就上优先级队列存储任务。线程始终在task先级队列~</span>
                    <span class="token comment">// 第一版发出来，后面再优化成阻塞队列的形式。。。</span>
                <span class="token punctuation">}</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 第一版有点小bug，咱们没排查出来~~~
     * @param args
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">AsyncScheduleFramework</span> framework <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AsyncScheduleFramework</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        framework<span class="token punctuation">.</span><span class="token function">addTask</span><span class="token punctuation">(</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;0/5 * * ? * *&quot;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;任务执行啦，时间：&quot;</span> <span class="token operator">+</span> <span class="token class-name">ZonedDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/*
     * 1、 首先new  AsyncScheduleFramework，就会开启一个线程，去遍历ConcurrentHashMap
     * 获取到里面存储的任务
     * 拿到任务后先判断任务的执行时间是否到了 &amp;&amp; 判断任务现在是否开启  &amp;&amp; 任务是第一次在定时任务执行
     * 在内部准备开始执行任务。
     *      1.1 先将第一次任务执行的标识修改掉，确保只执行一次。
     *      1.2 开启一个线程开始执行任务 ---  任务执行完毕，计算下次执行任务的时间，并且将第一次任务执行的标识重置
     *
     * 2、添加任务时的操作。
     * 基于cron表达式，计算出这个任务下次执行的时间
     * 封装ScheduleTask任务，并且将任务添加到ConcurrentHashMap集合里。
     */</span>

<span class="token punctuation">}</span>

</code></pre></div></blockquote> <h2 id="第二题当时的问题解决"><a href="#第二题当时的问题解决" class="header-anchor">#</a> 第二题当时的问题解决</h2> <blockquote><p>直接画图说了。</p> <p><img src="/Users/fengshouli/vuepressWorkspace/vuepress-start/docs/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB%E7%8F%AD/pic/b193a0b81a2c47eaa2497a1fe7496be2.png" alt="image.png"></p> <hr> <p><img src="/Users/fengshouli/vuepressWorkspace/vuepress-start/docs/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB%E7%8F%AD/pic/3549b4a34a5b45c9be34558427f05b6e.png" alt="image.png"></p> <hr> <p><img src="/Users/fengshouli/vuepressWorkspace/vuepress-start/docs/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB%E7%8F%AD/pic/b58e314a714f4b0b942bacecd1668f69.png" alt="image.png"></p> <hr> <p><img src="/Users/fengshouli/vuepressWorkspace/vuepress-start/docs/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB%E7%8F%AD/pic/9cd1456b57324db4aa1ba5aa73e30c7e.png" alt="image.png"></p> <hr> <p><img src="/Users/fengshouli/vuepressWorkspace/vuepress-start/docs/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB%E7%8F%AD/pic/e927598805cb4343b3094f487b14a1c5.png" alt="image.png"></p> <hr> <p><img src="/Users/fengshouli/vuepressWorkspace/vuepress-start/docs/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB%E7%8F%AD/pic/642ba3058fef4ba0a03ecd15b83a7f20.png" alt="image.png"></p> <p>这样问题就出现了，所以解决问题的方式很简单，把判断的顺序更改一下就可以了。</p> <p>将这个顺序</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token punctuation">.</span>nextExecuteTime<span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span><span class="token class-name">ZonedDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> task<span class="token punctuation">.</span>started <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>task<span class="token punctuation">.</span>running<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</code></pre></div><p>修改为</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>task<span class="token punctuation">.</span>running <span class="token operator">&amp;&amp;</span> task<span class="token punctuation">.</span>started <span class="token operator">&amp;&amp;</span> task<span class="token punctuation">.</span>nextExecuteTime<span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span><span class="token class-name">ZonedDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</code></pre></div><p>这样再走上述的逻辑，就不会出现重复执行任务的问题。</p> <p>只要线程池的线程没有执行完毕task.running = false，就不会进入到if的逻辑，哪怕出现了上述图中的逻辑，也会基于时间的第三个判断，进不去if，规避重复问题。</p></blockquote> <h2 id="_3、描述如何使用多线程来处理大数据集-例如在数据分析应用中-将数据拆分成多个部分并行处理-58同城"><a href="#_3、描述如何使用多线程来处理大数据集-例如在数据分析应用中-将数据拆分成多个部分并行处理-58同城" class="header-anchor">#</a> 3、描述如何使用多线程来处理大数据集，例如在数据分析应用中，将数据拆分成多个部分并行处理（58同城）</h2> <blockquote><p>这里最基本的线程池 + CountDownLatch就可以解决，至于代码实现。</p> <p>核心思路自然就将大数据集拆分成多个部分，分别交给线程池去处理，等到所有任务才完成后，汇总即可。</p> <p>实现部署步骤，大致分为几步：</p> <ul><li>首先需要将大数据集拆分成若干部分，比如数据体量在1000W，那可以将每个任务拆分成100W，分别交给线程去处理。</li> <li>还需要计算好任务的个数，利用CountDownLatch来做计数器，确保得知任务是否全部完成。</li> <li>讲封装好的任务投递到线程池中执行。</li> <li>主线程等待任务完毕后，拿到每一个结果进行汇总即可。</li></ul> <p>这里有几个小细节需要考虑。</p> <ul><li>首先是任务的切分，这里需要根据任务的情况来考虑
<ul><li>如果分析是单纯的CPU密集任务，那需要跟CPU内核个数考虑好，做好测试，如果并行的线程出太多，导致线程的上下文切换，会带来一定的性能损耗。</li> <li>如果分析是IO密集的任务，这种IO密集的任务，线程数需要的数量会大一些，这里具体的线程数需要通过压测去测试，其次如果是JDK21版本，可以考虑引入虚拟线程来提升处理的效率。</li></ul></li> <li>另外就是这种大规模的数据集，JVM内存是否能够一次性装下，如果在内存无法满足一次性获取时，需要做好分批次的处理流程。</li> <li>另外如果数据集的处理之前存在一些前后相互依赖的关系时，做好同步操作的事情，最好的方式，是利用CompletableFuture做好任务的编排工作。</li> <li>还有就是这种异步处理，咱们需要考虑可能存在一些异常问题，提前添加好处理异常的逻辑，出现问题时，要有一个补偿的措施。</li></ul></blockquote> <h2 id="_4、描述如何实现一个网络爬虫-利用多线程并行抓取多个网页-提高数据抓取的效率-百度ai"><a href="#_4、描述如何实现一个网络爬虫-利用多线程并行抓取多个网页-提高数据抓取的效率-百度ai" class="header-anchor">#</a> 4、描述如何实现一个网络爬虫，利用多线程并行抓取多个网页，提高数据抓取的效率（百度AI）</h2> <blockquote><p>咱们面的是Java岗位，别一看爬虫就想Python，首先Python爬数据，确实比Java好，但是Java也能抓一些数据的。</p> <p>爬取数据的整体过程，无非是获取对应的URL，访问URL获取对应的响应信息，Java就是利用Jsoup提供的API对数据进行解析，拿到对应的数据，落库即可。</p> <p>影响抓取数据效率的位置：</p> <ul><li>访问URL的过程。网络IO的时间成本高。</li> <li>利用Jsoup去解析数据时，如果单个URL反馈的数据体量太大，串行解析的成本比较高。</li> <li>URL可能重复，重复获取或者解析数据</li> <li>URL体量比较大，每次解析完都单独落库的话，对应MySQL的压力不小，而且多次找MySQL的网络IO，磁盘IO成本都很高。</li></ul> <p>问题有了，解决起来就方便了。</p> <ul><li>解决URL的网络IO成本，那就是直接线程池并行去访问URL，避免单个线程阻塞长时间等待。多个线程并行去访问URL。</li> <li>每个线程在获取的URL之后，根据单个URL的数据体量考虑，是否需要多个线程并行的利用Jsoup去解析，这里属于CPU密集的业务类型，线程个数不宜太高，当然如果单个URL数据体量不大，这里不需要并行去解析。</li> <li>可以在获取URL之后，甚至是发起请求到URL前，先利用Redis或者本地的CHM，确保访问一次即可，减少重复访问的问题。</li> <li>可以让每个解析完数据的线程，将数据扔到一个阻塞队列里，当数据个数达到一定程度，比如500，比如1000等等，根据具体的情况，做批量入库操作。</li></ul> <p>还可以再考虑点事：</p> <ul><li>做过爬虫的同学们都知道，不能随便爬，最好看看平台提供的rebots文件，确保满足对方的协议。。。</li> <li>毕竟是爬数据嘛，请求的体量不要太大，避免人家有反扒机制，封你IP，不过封IP也不怕，咱们可以上代理高动态IP。</li> <li>比如访问URL失败，做好重试或者是记录的一些操作。</li></ul></blockquote> <h2 id="_5、描述如何在java应用中使用多线程执行数据库的批量插入或更新操作-以提高数据库的写入效率-猫眼"><a href="#_5、描述如何在java应用中使用多线程执行数据库的批量插入或更新操作-以提高数据库的写入效率-猫眼" class="header-anchor">#</a> 5、描述如何在Java应用中使用多线程执行数据库的批量插入或更新操作，以提高数据库的写入效率（猫眼）</h2> <blockquote><p>核心就是任务划分，多线程并行执行批量插入操作。</p> <p>1、你需要根据你的数据集大小以及系统资源情况来合理的划分任务。比如你有10W的数据需要插入，咱们每个线程批量插入1000条数据，那就可以家境任务拆分成100份，让每个线程每次批量插入1000条数据即可。</p> <p>2、准备线程池，内部的线程个数要根据MySQL服务器那边的系统资源考虑，插入操作IO涉及的多一些，CPU资源还好，内存资源和连接数需要重点考虑。</p> <p>可以提前测试批量插入，查看一下MySQL所在服务的负载情况，主要查看越好CPU和内存的资源，不要达到太高的负载。。</p> <p>3、同样，Java端也需要考虑好线程池中的资源，比如阻塞队列，数据体量如果太大，内存能否抗住。线程数也要考虑好CPU的资源情况。</p> <p>一样，也是要做好压测的事情。</p> <p>4、准备好线程池，准备好任务，干活！！！！</p> <hr> <p>毕竟批量跟数据库操作，而且是多线程，需要考虑好死锁的问题。</p> <p>建议事务的隔离级别，上read committed。可以规避掉好多修改和插入并行的死锁问题。。。</p></blockquote></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/面试突击班/Mysql2024-下.html" class="prev">
        MySQL2024-下
      </a></span> <span class="next"><a href="/面试突击班/并发编程2024.html">
        并发编程2024-1
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e6553dd9.js" defer></script><script src="/assets/js/2.f327c6f6.js" defer></script><script src="/assets/js/1.65890b21.js" defer></script><script src="/assets/js/53.5f75e288.js" defer></script>
  </body>
</html>
