(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{716:function(t,a,s){"use strict";s.r(a);var e=s(17),r=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"indextree-ac自动机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#indextree-ac自动机"}},[t._v("#")]),t._v(" IndexTree,AC自动机")]),t._v(" "),a("h2",{attrs:{id:"indextree"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#indextree"}},[t._v("#")]),t._v(" IndexTree")]),t._v(" "),a("h3",{attrs:{id:"特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),a("ol",[a("li",[t._v("支持区间查询")]),t._v(" "),a("li",[t._v("没有线段树那么强，但是非常容易改成一维、二维、三维的结构")]),t._v(" "),a("li",[t._v("只支持单点更新")])]),t._v(" "),a("h3",{attrs:{id:"indextree的诞生"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#indextree的诞生"}},[t._v("#")]),t._v(" IndexTree的诞生")]),t._v(" "),a("p",[t._v("假如有一个数组,有个需求就是频繁的查询某些区间的累加和.例如7~12的,569~975的,")]),t._v(" "),a("p",[t._v("面对上面的需求,我们搞一个前缀和help数组,其实已经可以搞定了,例如7~12的就是1~12的减去1~7的,查一下减一下,O(1)可以做到.")]),t._v(" "),a("p",[t._v("但是,这都是建立在我help数组搞完了的基础上的,一旦说,某个位置的数变了呢,我辛苦建立的help,后面的数,全部都得重新算,这个成本是很高的.")]),t._v(" "),a("p",[t._v("所以我们需要一个高效的算法,好像这个上面的场景,说的不是线段树吗?不错,线段树能做,但是,IndexTree也有它的优势!")]),t._v(" "),a("h3",{attrs:{id:"核心算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#核心算法"}},[t._v("#")]),t._v(" 核心算法")]),t._v(" "),a("h4",{attrs:{id:"人为规定-1开始"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#人为规定-1开始"}},[t._v("#")]),t._v(" 人为规定,1开始,")]),t._v(" "),a("p",[t._v("假设数组下标,1,2,3,4,5,6,7,8,9,10,11,12")]),t._v(" "),a("p",[t._v("累加和,help数组[1,(1,2),3,(1~4),5,(5,6),7,(1~8),9,(9~10),11,(9~12)],")]),t._v(" "),a("p",[t._v("那当我有index位置的值变化的时候,我需要更新哪些地方呢?")]),t._v(" "),a("p",[t._v("给index展开为2进制的,然后,去掉最后的1,最后加个1,这个数~index的,就是需要改的范围.")]),t._v(" "),a("p",[t._v("例如,8位置的变了,0001000,那他去掉最后的1,最后加个1,就是00000000,范围就是1~8.")]),t._v(" "),a("p",[t._v("12位置变了,0001100,那他去掉最后的1,最后加个1,就是0001001,范围就是9~12.完全符合上面的规律.")]),t._v(" "),a("h4",{attrs:{id:"干啥用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#干啥用"}},[t._v("#")]),t._v(" 干啥用?")]),t._v(" "),a("p",[t._v("我如何更新我的这个新的辅助数组结构啊.")]),t._v(" "),a("p",[t._v("假设任意的index位置变了,我还是求累加和,哪个位置受牵连?")]),t._v(" "),a("p",[t._v("例如0000110100,上面说了,他这个index位置就是负责0000110100~000011001的,")]),t._v(" "),a("p",[t._v("我们这么算.给他分段.")]),t._v(" "),a("p",[t._v("首先算arr 0110001~0110100,抹掉一个最右侧的1了")]),t._v(" "),a("p",[t._v("然后算arr 010001~0110000,再抹掉一个最右侧的1.")]),t._v(" "),a("p",[t._v("最后算arr 000001~0100000,发现没有,这三段是挨着的.")]),t._v(" "),a("h4",{attrs:{id:"所以怎么变受牵连的位置的值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#所以怎么变受牵连的位置的值"}},[t._v("#")]),t._v(" 所以怎么变受牵连的位置的值?")]),t._v(" "),a("p",[t._v("找受牵连的位置,给他们都+变化的值.")]),t._v(" "),a("p",[t._v("首先index位置,要变,然后,下一个,最末尾的1加起来,例如,6位置,110,最末尾的1,是10,加一起,就是1000,8位置,然后再最末尾1加起来,10000,16,然后再加,100000,32,所以说,只要不超过数组范围,一直加,这些都是受牵连的位置.")]),t._v(" "),a("p",[t._v("复杂度,logN,最多也就那么多个1嘛.")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("index "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("N")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\t\ttree"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" d"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//负数就是取反+1,提取最右侧的1,就是自己&取反+1")]),t._v("\n\t\t\t\tindex "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" index "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\t\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h4",{attrs:{id:"所以怎么求累加和"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#所以怎么求累加和"}},[t._v("#")]),t._v(" 所以怎么求累加和?")]),t._v(" "),a("p",[t._v("前缀树就是后面的减前面的,IndexTree是前面的1的位置的,一点点剥离出来然后怼上去.")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("index "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\t\tret "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" tree"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\t\t\tindex "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-=")]),t._v(" index "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\t\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h2",{attrs:{id:"ac自动机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ac自动机"}},[t._v("#")]),t._v(" AC自动机")]),t._v(" "),a("p",[t._v("解决在一个大字符串中，找到多个候选字符串的问题")]),t._v(" "),a("h3",{attrs:{id:"ac自动机算法核心"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ac自动机算法核心"}},[t._v("#")]),t._v(" AC自动机算法核心")]),t._v(" "),a("ol",[a("li",[t._v("把所有匹配串生成一棵前缀树")]),t._v(" "),a("li",[t._v("前缀树节点增加fail指针")]),t._v(" "),a("li",[t._v("fail指针的含义：如果必须以当前字符结尾，当前形成的路径是str，剩下哪一个字符串的前缀和str的后缀，拥有最大的匹配长度。fail指针就指向那个字符串的最后一个字符所对应的节点。（迷不迷？听讲述！）")])])])}),[],!1,null,null,null);a.default=r.exports}}]);