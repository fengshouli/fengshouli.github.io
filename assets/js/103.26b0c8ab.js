(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{719:function(e,a,f){"use strict";f.r(a);var o=f(17),t=Object(o.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"mysql突击班-第二天"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql突击班-第二天"}},[e._v("#")]),e._v(" MySQL突击班（第二天）")]),e._v(" "),a("h2",{attrs:{id:"一、buffer-pool-在2025中整理了-主要看2025"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、buffer-pool-在2025中整理了-主要看2025"}},[e._v("#")]),e._v(" 一、Buffer Pool-在2025中整理了,主要看2025")]),e._v(" "),a("h2",{attrs:{id:"二、change-buffer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、change-buffer"}},[e._v("#")]),e._v(" 二、Change Buffer")]),e._v(" "),a("h3",{attrs:{id:"_2-1-change-buffer是个啥"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-change-buffer是个啥"}},[e._v("#")]),e._v(" 2.1 Change Buffer是个啥？")]),e._v(" "),a("blockquote",[a("p",[e._v("Change Buffer是针对MySQL中，使用二级索引（非聚簇索引）去写数据时优化的一个策略。是在进行DML操作时的一个优化。")]),e._v(" "),a("p",[e._v("如果写的是 "),a("strong",[e._v("非聚簇索引")]),e._v(" ，并且对应的 "),a("strong",[e._v("数据页没有在Buffer Pool")]),e._v(" ，此时他不会立即将磁盘中的数据库页加载到Buffer Pool中。而是先将写操作扔到Change Buffer中，做一个缓冲。")]),e._v(" "),a("p",[e._v("等后面，要修改的这个数据页被读取时，再将Change Buffer中的记录合并到Buffer Pool中。"),a("strong",[e._v("这样就是为了减少磁盘IO次数，提高性能。")])]),e._v(" "),a("p",[a("strong",[e._v("一级索引不会触发Change Buffer，一级索引速度快，直接把磁盘数据扔到Buffer Pool中，然后内存修改即可。")])]),e._v(" "),a("p",[e._v("Change Buffer占用的是Buffer Pool的空间，默认占用25%，最大允许到50%。可以根据配置来进行调整。一般25%足够了，除非你的MySQL写多读少，可以适当调大Change Buffer的比例。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1725536056014/3751b21f27d742698a72eb8eacfd73f9.png",alt:"image.png"}})]),e._v(" "),a("p",[e._v("二级索引修改整体流程：")]),e._v(" "),a("ul",[a("li",[e._v("更新一条记录时，当该记录在Buffer Pool缓冲区中时，直接在Buffer Pool中修改对应的页，一次内存操作。（end）")]),e._v(" "),a("li",[e._v("如果该记录不在Buffer Pool缓冲区中时，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存在Change Buffer中，不去磁盘做IO操作。。")]),e._v(" "),a("li",[e._v("当下次查询到该记录时，会将这个记录扔到Buffer Pool，然后Change Buffer会将和这个也有关的操作合并，进行修改。")])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1725536056014/38e94ddebd10413dbd3138bbda2228fa.png",alt:"image.png"}})])]),e._v(" "),a("h3",{attrs:{id:"_2-2-数据到changebuffer后-mysql宕机了咋整"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-数据到changebuffer后-mysql宕机了咋整"}},[e._v("#")]),e._v(" 2.2 数据到ChangeBuffer后，MySQL宕机了咋整？")]),e._v(" "),a("blockquote",[a("p",[e._v("首先要清楚，当一个事务提交时，InnoDB会将事务的所有更改记录写到redo log（重做日志）中，包括哪些写入到Change Buffer中的内容。咱们的保障是基于redo log实现的，即便宕机，redo log也有完整的信息。当前MySQL还会基于bin log利用2PC的形式，确保数据一致性。")])]),e._v(" "),a("h2",{attrs:{id:"三、ahi"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、ahi"}},[e._v("#")]),e._v(" 三、AHI")]),e._v(" "),a("h3",{attrs:{id:"_3-1-ahi是个啥"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-ahi是个啥"}},[e._v("#")]),e._v(" 3.1 AHI是个啥？")]),e._v(" "),a("blockquote",[a("p",[e._v("AHI（自适应Hash索引，Adaptive Hash Index），他是InnoDB存储特有的。是一个为了优化查询操作的特殊功能。")]),e._v(" "),a("p",[e._v("当AHI发现某些索引值使用的非常的频繁，建立hash索引来提升查询的效率。")]),e._v(" "),a("p",[e._v("AHI也是存储再Buffer Pool中的，会在Buffer Pool中开辟一片区域，建议这种自适应hash索引。")]),e._v(" "),a("p",[e._v("而且AHI默认是开启的。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1725536056014/a172778966eb495fb90479c757d88cdb.png",alt:"image.png"}})]),e._v(" "),a("p",[e._v("画一个图，掌握这种AHI是啥效果。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1725536056014/3b031315620c47b98410aaa4227123e5.png",alt:"image.png"}})]),e._v(" "),a("p",[e._v("AHI的一些参数，不需要做任何调整，默认即可。 在生成AHI的自适应Hash索引后，查询效率可以从B+Tree结构的 "),a("code",[e._v("O(logn)")]),e._v("  提升到  "),a("code",[e._v("O(1)")]),e._v(" 的效率。")])]),e._v(" "),a("h2",{attrs:{id:"四、log-buffer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、log-buffer"}},[e._v("#")]),e._v(" 四、Log Buffer")]),e._v(" "),a("blockquote",[a("p",[e._v("Log Buffer是存储要写入到磁盘上的日志文件的一片内存区域。主要是redo log。")]),e._v(" "),a("p",[e._v("默认占用16M的大小。可以用过 "),a("code",[e._v("innodb_log_buffer_size")]),e._v("  参数调整。")]),e._v(" "),a("p",[e._v("他的目的很简单，就是在你做写操作时，尽量减少日志写入磁盘时的IO损耗，减少IO的次数……")])]),e._v(" "),a("h2",{attrs:{id:"五、redo-log"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、redo-log"}},[e._v("#")]),e._v(" 五、redo log")]),e._v(" "),a("h3",{attrs:{id:"_5-1-redo-log是个啥"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-redo-log是个啥"}},[e._v("#")]),e._v(" 5.1 redo log是个啥？")]),e._v(" "),a("blockquote",[a("p",[e._v("redo log（重做日志）是InnoDB独有的。它让MySQL用于了崩溃回复的能力（一般配合bin log）。也就是MySQL宕机后，他可以根据redo log来恢复近期的数据，保证之前还没有写入到磁盘中的数据不会丢失，保证持久性和完整性。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1725536056014/c0a503e9190b43d89ed6be2b2abfe92a.png",alt:"image.png"}})])]),e._v(" "),a("h3",{attrs:{id:"_5-2-redo-log如何保证数据的完整。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-redo-log如何保证数据的完整。"}},[e._v("#")]),e._v(" 5.2 redo log如何保证数据的完整。")]),e._v(" "),a("blockquote",[a("p",[e._v("首先，现在知道一个事情，MySQL写操作不会立即将数据落到磁盘上，无论是数据还是日志。")]),e._v(" "),a("p",[e._v("比如数据，他优先走Change Buffer以及Buffer Pool的内存中，也是MySQL优化的手段，减少IO的消耗。")]),e._v(" "),a("p",[e._v("所有，为了保证数据的完整和持久性，在修改Change Buffer和Buffer Pool中的数据时，数据会优先落到redo log中。")]),e._v(" "),a("p",[e._v("写入的流程，如下")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1725536056014/d4474d9520f446a2846641bf8795ed7d.png",alt:"image.png"}})]),e._v(" "),a("p",[e._v("我只需要知道第4步的触发时机即可。")]),e._v(" "),a("p",[a("strong",[e._v("redo log大概存储表空间号 + 数据页号 + 偏移量 + 具体修改的数据………………")])]),e._v(" "),a("p",[e._v("而Log Buffer中的数据刷到磁盘中，一般主要由这个参数控制")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1725536056014/6ebd301f2ede4e68bcbc40428adbd657.png",alt:"image.png"}})]),e._v(" "),a("p",[e._v("他的默认值是1。他可以提供三种值：")]),e._v(" "),a("ul",[a("li",[e._v("0： 设置为0的时候，表示每次事务提交不刷盘……")]),e._v(" "),a("li",[e._v("1： （默认值）设置为1的时候，表示每次事务提交后，会立即进行刷盘操作……")]),e._v(" "),a("li",[e._v("2：设置为2的时候，标识每次事务提交，我需要将Log Buffer中的数据刷到系统内存中……")])]),e._v(" "),a("p",[e._v("就用1，别用别的，别的会导致丢失数据…………")]),e._v(" "),a("p",[e._v("刷盘的流程大致长这样")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1725536056014/ebdfbc211f4d4f2f9f8d90b2b6d06bb5.png",alt:"image.png"}})]),e._v(" "),a("p",[e._v("下面详细的把，0，1，2的配置的刷盘套路各画一个图。")]),e._v(" "),a("ul",[a("li",[e._v("当设置为0的时候，没有任何机制会主动刷新，只能靠后台提供的一个线程，每一秒刷新Log Buffer数据到File Cache"),a("img",{attrs:{src:"https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1725536056014/0bd64e9cb6da41ec9c29cf22bed7a6d6.png",alt:"image.png"}})]),e._v(" "),a("li",[e._v("当设置为1的时候，只要提交事务，就一定会确保Log Buffer中的数据，落到File Cache并且，必须序列化到本地磁盘文件"),a("img",{attrs:{src:"https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1725536056014/d83c06323ffa4e12b4a3e3f8a18a3aa3.png",alt:"image.png"}})]),e._v(" "),a("li",[e._v("设置为2时，提交事务后，会确保Log Buffer的数据，一定要了File Cache中。"),a("img",{attrs:{src:"https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1725536056014/03e256f55de7423792dbe02f54344453.png",alt:"image.png"}})])])])])}),[],!1,null,null,null);a.default=t.exports}}]);