(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{720:function(v,_,s){"use strict";s.r(_);var t=s(17),r=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"数组三连问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数组三连问题"}},[v._v("#")]),v._v(" 数组三连问题.")]),v._v(" "),_("h3",{attrs:{id:"题目一"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#题目一"}},[v._v("#")]),v._v(" 题目一")]),v._v(" "),_("blockquote",[_("p",[v._v("给定一个正整数组成的无序数组arr，给定一个正整数值K\n找到arr的所有子数组里，哪个子数组的累加和等于K，并且是长度最大的\n返回其长度")])]),v._v(" "),_("p",[v._v("主要技巧：利用单调性优化")]),v._v(" "),_("p",[v._v("都是正数的,来一个窗口就可以解决,因为他是有单调性的,")]),v._v(" "),_("p",[v._v("新来一个数,一定会让子数组的累加和变大,吐出去一个数一定会让累加和变小")]),v._v(" "),_("h3",{attrs:{id:"题目二"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#题目二"}},[v._v("#")]),v._v(" 题目二")]),v._v(" "),_("blockquote",[_("p",[v._v("给定一个整数组成的无序数组arr，值可能正、可能负、可能0\n给定一个整数值K\n找到arr的所有子数组里，哪个子数组的累加和等于K，并且是长度最大的\n返回其长度")])]),v._v(" "),_("p",[v._v("主要技巧：利用预处理结构优化 + 讨论开头结尾 (大的子数组 - 小的子数组)")]),v._v(" "),_("p",[v._v("有负数了,那么就失去了单调性了,不能用窗口了.")]),v._v(" "),_("p",[v._v("子数组,我们老传统思想了,以i位置开头或结尾,最远推多远.")]),v._v(" "),_("p",[v._v("我们先对数组求一个累加和数组,则0~i位置的累加和sum我们很容易就能得到.假设100.")]),v._v(" "),_("p",[v._v("然后我们想求累加和为K的,例如k=30,那我们实际想求一个,有没有sum=70的,如果有,那我们累加和一减,不就是累加和=30的子数组吗.")]),v._v(" "),_("p",[v._v("如果没有,那我把当前累加和的位置存起来.")]),v._v(" "),_("p",[v._v("注意,建立位置Map的时候,先要把(0,-1)位置存进去.这样,才能对")]),v._v(" "),_("p",[v._v("例如[5,-5............],k=0,当遍历到0~1时候,我其实已经发现答案了,但是由于没有(0,-1)这个记录,我收集不到.")]),v._v(" "),_("h3",{attrs:{id:"题目三"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#题目三"}},[v._v("#")]),v._v(" 题目三")]),v._v(" "),_("blockquote",[_("p",[v._v("给定一个整数组成的无序数组arr，值可能正、可能负、可能0\n给定一个整数值K\n找到arr的所有子数组里，哪个子数组的累加和<=K，并且是长度最大的\n返回其长度")])]),v._v(" "),_("p",[v._v("主要技巧：假设答案法+淘汰可能性（很难，以后还会见到）")]),v._v(" "),_("p",[v._v("这个题需要用到2个辅助结构.")]),v._v(" "),_("p",[v._v("和原答案一样长的两个子数组")]),v._v(" "),_("p",[v._v("minSums[],他记录的是,从i位置往后推,最小子数组sum值数组,他是倒着推出来的,从右往左,是否要包含右边的进来,还是只包含自己 的一个动态规划")]),v._v(" "),_("p",[v._v("minSumEnds[],他和上面的辅助数组是一对儿,相辅相成的,他记录的是,上面得到了一个最小值之后,最右位置是多少.")]),v._v(" "),_("p",[v._v("例如 minSums[5] = 32,minSumEnds[5] = 7,代表5~7位置的累加和sum=32.")]),v._v(" "),_("p",[v._v("如果是minSums[12] = -5,minSumEnds[12] = 12,代表12位置自己组成的累加和sum=-5,他不往右扩是最好的.")]),v._v(" "),_("p",[v._v("这俩干嘛用????")]),v._v(" "),_("p",[v._v("我求累加和<=K的最长子数组,")]),v._v(" "),_("p",[v._v("我从0开始,看看最远推多远.")]),v._v(" "),_("p",[v._v("假设,我的辅助数组告诉我,0~3 = 4,4~6 = 3,7~10 = 5,k=10.")]),v._v(" "),_("p",[v._v("那我发现第一个最小子数组0~3的sum<=k 10,所以我把下一个最小子数组吸收进来,发现0~6 的sum = 7<= k 10,我继续吸收右面的子数组,,如果还能吸收,则吸收进来,如果不行了!!!我左侧往出退数,然后看能不能吸收进来新的子数组sum,")]),v._v(" "),_("p",[v._v("例如0~7,满足,但是发现8吸收进来就超了,吐出去0,看看0~7 的sum-arr[0] + minSums[8]能不能行,如果不行,反正它不影响我正确答案,只考虑他能不能吸收进来,推高可能性.")]),v._v(" "),_("p",[v._v("整个数组不回退的.")])])}),[],!1,null,null,null);_.default=r.exports}}]);