(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{669:function(v,_,t){v.exports=t.p+"assets/img/54e550619d222cfa3da258fae3154eca.3536775a.png"},670:function(v,_,t){v.exports=t.p+"assets/img/a03c2f769795d68706a154702116b88d.56437188.png"},671:function(v,_,t){v.exports=t.p+"assets/img/4f5207330d94a093909f6c873a146565.e05c3987.png"},672:function(v,_,t){v.exports=t.p+"assets/img/6f7e21a721aa0a71c1baca40ee0b1f8b.3c852a1e.png"},673:function(v,_,t){v.exports=t.p+"assets/img/a1c66041ee11b415233f1e357f3fe0c4.48b54912.png"},674:function(v,_,t){v.exports=t.p+"assets/img/2ca9edaa4010b045e9e9bb7da5bc93b3.c8713bc3.png"},675:function(v,_,t){v.exports=t.p+"assets/img/86d70cdd7192e564c31998856a8ed675.5953f930.png"},976:function(v,_,t){"use strict";t.r(_);var a=t(17),r=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"mq-2025上"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mq-2025上"}},[v._v("#")]),v._v(" MQ-2025上")]),v._v(" "),_("h2",{attrs:{id:"rabbitmq的消息处理模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq的消息处理模型"}},[v._v("#")]),v._v(" RabbitMQ的消息处理模型")]),v._v(" "),_("h3",{attrs:{id:"rabbitmq的消息处理模型-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq的消息处理模型-2"}},[v._v("#")]),v._v(" RabbitMQ的消息处理模型")]),v._v(" "),_("p",[_("img",{attrs:{src:t(669),alt:"image.png"}})]),v._v(" "),_("p",[v._v("RabbitMQ 是一个基于 "),_("strong",[v._v("AMQP（Advanced Message Queuing Protocol）")]),v._v(" 协议的消息队列系统")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("生产者（Producer）")])]),v._v(" "),_("li",[_("strong",[v._v("交换器（Exchange）")])]),v._v(" "),_("li",[_("strong",[v._v("路由键（Routing Key）")])]),v._v(" "),_("li",[_("strong",[v._v("队列（Queue）")])]),v._v(" "),_("li",[_("strong",[v._v("消费者（Consumer）")])]),v._v(" "),_("li",[_("strong",[v._v("生产者（Producer）")])])]),v._v(" "),_("p",[v._v("生产者是消息的发送者，负责创建消息并将其发送到 RabbitMQ 的交换器（Exchange）。")]),v._v(" "),_("p",[v._v("生产者通过 "),_("code",[v._v("RabbitTemplate")]),v._v(" 或 AMQP 客户端将消息发送到交换器")]),v._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[_("strong",[v._v("交换器（Exchange）")])])]),v._v(" "),_("p",[v._v("交换器是消息的路由中心，负责接收生产者发送的消息，并根据 "),_("strong",[v._v("路由键（Routing Key）")]),v._v(" 和 "),_("strong",[v._v("绑定规则（Binding）")]),v._v(" 将消息分发到一个或多个队列。")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("类型")]),v._v(" ：RabbitMQ 支持多种交换器类型，每种类型有不同的路由规则：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("Direct Exchange")]),v._v(" ：精确匹配路由键。")]),v._v(" "),_("li",[_("strong",[v._v("Topic Exchange")]),v._v(" ：基于通配符匹配路由键。")]),v._v(" "),_("li",[_("strong",[v._v("Fanout Exchange")]),v._v(" ：广播消息到所有绑定的队列。")])])])]),v._v(" "),_("p",[_("strong",[v._v("3.路由键（Routing Key）")])]),v._v(" "),_("p",[v._v("路由键是生产者发送消息时指定的一个字符串，用于决定消息如何从交换器路由到队列。")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("作用")]),v._v(" ：交换器根据路由键和绑定规则将消息分发到队列。")]),v._v(" "),_("li",[_("strong",[v._v("匹配规则")]),v._v(" ：不同的交换器类型对路由键的匹配方式不同。")])]),v._v(" "),_("p",[_("strong",[v._v("4.队列（Queue）")])]),v._v(" "),_("p",[v._v("队列是消息的存储容器，用于存储从交换器路由过来的消息，直到消费者处理它们。")]),v._v(" "),_("p",[_("strong",[v._v("5.消费者（Consumer）")])]),v._v(" "),_("p",[v._v("消费者是消息的接收者，负责从队列中获取消息并进行处理。")]),v._v(" "),_("ul",[_("li",[v._v("消费者订阅队列，RabbitMQ 会将队列中的消息推送给消费者。")]),v._v(" "),_("li",[v._v("消费者处理完消息后，需要向 RabbitMQ 发送确认（ACK），表示消息已成功处理。")])]),v._v(" "),_("h3",{attrs:{id:"kafka的消息处理模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#kafka的消息处理模型"}},[v._v("#")]),v._v(" Kafka的消息处理模型")]),v._v(" "),_("p",[_("img",{attrs:{src:t(670),alt:"image.png"}})]),v._v(" "),_("p",[v._v("Kafka 是一个分布式的流处理平台，其消息处理模型基于  "),_("strong",[v._v("发布-订阅模式")]),v._v(" ，核心组件包括  "),_("strong",[v._v("生产者（Producer）")]),v._v(" 、 "),_("strong",[v._v("Kafka 集群（Brokers）")]),v._v(" 、 "),_("strong",[v._v("主题（Topic）")]),v._v(" 、"),_("strong",[v._v("分区（Partition）")]),v._v(" 和 "),_("strong",[v._v("消费者（Consumer）")])]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("生产者发送消息")]),v._v(" ：")]),v._v(" "),_("ul",[_("li",[v._v("生产者将消息发送到  "),_("strong",[v._v("主题 A")]),v._v(" 。")]),v._v(" "),_("li",[v._v("根据消息的键（Key）或轮询策略，消息被分配到 "),_("strong",[v._v("分区 0")]),v._v(" 或  "),_("strong",[v._v("分区 1")]),v._v(" 。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("消息存储")]),v._v(" ：")]),v._v(" "),_("ul",[_("li",[v._v("如果消息被分配到  "),_("strong",[v._v("分区 0")]),v._v(" ，它会被存储在 "),_("strong",[v._v("Broker1")]),v._v(" 上（因为 "),_("strong",[v._v("分区 0")]),v._v(" 的首领在 "),_("strong",[v._v("Broker1")]),v._v(" 上）。")]),v._v(" "),_("li",[v._v("如果消息被分配到  "),_("strong",[v._v("分区 1")]),v._v(" ，它会被存储在 "),_("strong",[v._v("Broker2")]),v._v(" 上（因为 "),_("strong",[v._v("分区 1")]),v._v(" 的首领在 "),_("strong",[v._v("Broker2")]),v._v(" 上）。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("消费者消费消息")]),v._v(" ：")]),v._v(" "),_("ul",[_("li",[v._v("消费者组中的消费者订阅  "),_("strong",[v._v("主题 A")]),v._v(" 。")]),v._v(" "),_("li",[v._v("消费者 1 从  "),_("strong",[v._v("分区 0")]),v._v(" （位于  "),_("strong",[v._v("Broker1")]),v._v(" ）读取消息。")]),v._v(" "),_("li",[v._v("消费者 2 从  "),_("strong",[v._v("分区 1")]),v._v(" （位于  "),_("strong",[v._v("Broker2")]),v._v(" ）读取消息。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("并行处理")]),v._v(" ：")]),v._v(" "),_("ul",[_("li",[v._v("由于 "),_("strong",[v._v("分区 0")]),v._v(" 和 "),_("strong",[v._v("分区 1")]),v._v(" 位于不同的 Broker 上，消费者可以并行处理消息，提高吞吐量。")])])])]),v._v(" "),_("p",[_("img",{attrs:{src:t(671),alt:"image.png"}})]),v._v(" "),_("h3",{attrs:{id:"rocketmq的消息处理模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq的消息处理模型"}},[v._v("#")]),v._v(" RocketMQ的消息处理模型")]),v._v(" "),_("p",[_("img",{attrs:{src:t(672),alt:"image.png"}})]),v._v(" "),_("p",[v._v("RocketMQ 是一个分布式消息中间件，其消息处理模型基于  "),_("strong",[v._v("发布-订阅模式")]),v._v(" ，核心组件包括  "),_("strong",[v._v("生产者（Producer）")]),v._v(" 、 "),_("strong",[v._v("Broker")]),v._v(" 、 "),_("strong",[v._v("NameServer")]),v._v(" 、"),_("strong",[v._v("主题（Topic）、队列")]),v._v(" 和 "),_("strong",[v._v("消费者（Consumer）")])]),v._v(" "),_("p",[v._v("NameServer 是 RocketMQ 的轻量级服务发现组件，负责管理 Broker 的路由信息。")]),v._v(" "),_("p",[v._v("Broker 是 RocketMQ 的消息存储和转发节点，负责存储消息、处理生产者和消费者的请求。")]),v._v(" "),_("p",[_("strong",[v._v("主题（Topic）")])]),v._v(" "),_("ul",[_("li",[v._v("主题可以创建在一台 Master 上，也可以创建在多台 Master 上以提高并发能力。")]),v._v(" "),_("li",[v._v("如果主题创建在多台 Master 上，消息会被均匀分布到不同的 Master。")])]),v._v(" "),_("p",[_("strong",[v._v("消息处理流程")])]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("主题创建")]),v._v(" ：\n"),_("ul",[_("li",[_("strong",[v._v("主题 A")]),v._v(" 可以创建在 "),_("strong",[v._v("Master1")]),v._v(" 上，也可以同时创建在 "),_("strong",[v._v("Master1")]),v._v(" 和 "),_("strong",[v._v("Master2")]),v._v(" 上。")]),v._v(" "),_("li",[v._v("如果创建在 "),_("strong",[v._v("Master1")]),v._v(" 和 "),_("strong",[v._v("Master2")]),v._v(" 上，消息会被均匀分布到两个 Master，提高并发能力。")])])]),v._v(" "),_("li",[_("strong",[v._v("生产者发送消息")]),v._v(" ：\n"),_("ul",[_("li",[v._v("生产者将消息发送到  "),_("strong",[v._v("主题 A")]),v._v(" 。")]),v._v(" "),_("li",[v._v("如果 "),_("strong",[v._v("主题 A")]),v._v(" 创建在 "),_("strong",[v._v("Master1")]),v._v(" 和 "),_("strong",[v._v("Master2")]),v._v(" 上，消息会被均匀分布到 "),_("strong",[v._v("Master1")]),v._v(" 和  "),_("strong",[v._v("Master2")]),v._v(" 。")])])]),v._v(" "),_("li",[_("strong",[v._v("消息存储")]),v._v(" ：\n"),_("ul",[_("li",[v._v("消息被存储在 "),_("strong",[v._v("Master1")]),v._v(" 或 "),_("strong",[v._v("Master2")]),v._v(" 的队列中。")]),v._v(" "),_("li",[_("strong",[v._v("Slave1")]),v._v(" 和 "),_("strong",[v._v("Slave2")]),v._v(" 分别从 "),_("strong",[v._v("Master1")]),v._v(" 和 "),_("strong",[v._v("Master2")]),v._v(" 同步数据，提供数据备份。")])])]),v._v(" "),_("li",[_("strong",[v._v("消费者消费消息")]),v._v(" ：\n"),_("ul",[_("li",[v._v("消费者从 "),_("strong",[v._v("Master1")]),v._v(" 或 "),_("strong",[v._v("Master2")]),v._v(" 的队列中拉取消息。")]),v._v(" "),_("li",[v._v("如果 "),_("strong",[v._v("Master1")]),v._v(" 阻塞或宕机，消费者可以从 "),_("strong",[v._v("Slave1")]),v._v(" 消费消息。")]),v._v(" "),_("li",[v._v("如果 "),_("strong",[v._v("Master2")]),v._v(" 阻塞或宕机，消费者可以从 "),_("strong",[v._v("Slave2")]),v._v(" 消费消息。")])])])]),v._v(" "),_("h2",{attrs:{id:"如何在mq中实现消息的顺序性-分析相关的设计与实现细节"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何在mq中实现消息的顺序性-分析相关的设计与实现细节"}},[v._v("#")]),v._v(" 如何在MQ中实现消息的顺序性，分析相关的设计与实现细节！")]),v._v(" "),_("p",[v._v("为了保证消息的顺序性，通常需要遵循以下规则：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("单线程生产")]),v._v(" ：确保生产者以单线程方式发送消息，避免并发发送导致消息乱序。")]),v._v(" "),_("li",[_("strong",[v._v("单线程消费")]),v._v(" ：确保消费者以单线程方式消费消息，避免并发消费导致消息乱序。")]),v._v(" "),_("li",[_("strong",[v._v("单个队列")]),v._v(" ：将所有消息发送到同一个队列中，确保消息的顺序性。")]),v._v(" "),_("li",[_("strong",[v._v("单个生产者/消费者")]),v._v(" ：避免多个生产者或消费者同时操作同一个队列，导致消息顺序混乱。")])]),v._v(" "),_("h3",{attrs:{id:"rabbitmq"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq"}},[v._v("#")]),v._v(" RabbitMQ")]),v._v(" "),_("p",[v._v("消息重试机制可以确保消息在消费失败后重新入队，从而保证消息的顺序性。")]),v._v(" "),_("p",[v._v("如果消费者处理消息失败，将消息重新放回队列头部，确保消息顺序不变。")]),v._v(" "),_("h4",{attrs:{id:"事务消息"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务消息"}},[v._v("#")]),v._v(" "),_("strong",[v._v("事务消息")])]),v._v(" "),_("p",[v._v("事务消息可以确保消息的发送和业务逻辑的原子性，从而保证消息的顺序性。")]),v._v(" "),_("p",[v._v("如果对消息顺序性要求极高，且可以接受性能损失，可以选择  "),_("strong",[v._v("事务消息")]),v._v(" 。")]),v._v(" "),_("h4",{attrs:{id:"rpc-模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rpc-模式"}},[v._v("#")]),v._v(" "),_("strong",[v._v("RPC 模式")])]),v._v(" "),_("p",[v._v("RPC 模式可以确保消息的顺序性，通过同步调用方式实现。")]),v._v(" "),_("p",[v._v("如果需要同步调用并保证顺序性，可以选择  "),_("strong",[v._v("RPC 模式")]),v._v(" 。")]),v._v(" "),_("h3",{attrs:{id:"kafka和rocketmq"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#kafka和rocketmq"}},[v._v("#")]),v._v(" Kafka和RocketMQ")]),v._v(" "),_("p",[v._v("在 Kafka 和RocketMQ中，一个分区/队列只能被同一个消费者组中的一个消费者消费。通过限制消费者组的消费者数量，可以确保消息的顺序性。")]),v._v(" "),_("p",[v._v("Kafka中：")]),v._v(" "),_("p",[_("code",[v._v("max.in.flight.requests.per.connection")]),v._v("：**控制每个连接上未确认的请求数量。设置为1")]),v._v(" "),_("p",[v._v("RocketMQ中：\n选用顺序的消费者方法或者类。")]),v._v(" "),_("h2",{attrs:{id:"描述mq中的消息确认机制-如rabbitmq-rocketmq的ack机制-分析源码中如何处理消息的确认与重发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#描述mq中的消息确认机制-如rabbitmq-rocketmq的ack机制-分析源码中如何处理消息的确认与重发"}},[v._v("#")]),v._v(" 描述MQ中的消息确认机制（如RabbitMQ\\RocketMQ的ack机制），分析源码中如何处理消息的确认与重发")]),v._v(" "),_("p",[v._v("RabbitMQ与Kafka和RocketMQ不一样，进行完ACK确认后，RabbitMQ会删除消息，其他的（kafka和RocketMQ）他们是不会删除，只会进行消费偏移量管理的。")]),v._v(" "),_("p",[v._v("RocketMQ 的消息确认机制基于 "),_("strong",[v._v("消费者拉取消息")]),v._v(" 和  "),_("strong",[v._v("消费进度提交")]),v._v(" 。")]),v._v(" "),_("p",[v._v("Kafka 的消息确认机制基于  "),_("strong",[v._v("消费者提交偏移量（Offset）")]),v._v(" 。")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("RabbitMQ")]),v._v(" ：\n"),_("ul",[_("li",[v._v("通过 Confirm 模式和手动 ACK 确保消息可靠传递。")]),v._v(" "),_("li",[v._v("支持 NACK 重新入队和重试机制。")])])]),v._v(" "),_("li",[_("strong",[v._v("RocketMQ")]),v._v(" ：\n"),_("ul",[_("li",[v._v("通过消费进度提交确保消息可靠传递。")]),v._v(" "),_("li",[v._v("支持重试队列，提供多级别重试策略。")])])]),v._v(" "),_("li",[_("strong",[v._v("Kafka")]),v._v(" ：\n"),_("ul",[_("li",[v._v("通过偏移量提交确保消息可靠传递。")]),v._v(" "),_("li",[v._v("无内置重试机制，需开发者自行实现。")])])])]),v._v(" "),_("p",[_("img",{attrs:{src:t(673),alt:"image.png"}})]),v._v(" "),_("h2",{attrs:{id:"使用mq的延迟消息实现限时订单"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用mq的延迟消息实现限时订单"}},[v._v("#")]),v._v(" 使用MQ的延迟消息实现限时订单")]),v._v(" "),_("h3",{attrs:{id:"rabbitmq-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-2"}},[v._v("#")]),v._v(" RabbitMQ")]),v._v(" "),_("p",[v._v("RabbitMQ本身不支持延迟消息，但可以通过死信队列（DLX）和消息TTL（Time-To-Live）来实现延迟效果。")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("创建普通队列和死信队列")]),v._v(" ：\n"),_("ul",[_("li",[v._v("创建一个普通队列，并设置消息的TTL（即消息的存活时间）。")]),v._v(" "),_("li",[v._v("创建一个死信队列，用于接收超时的消息。")])])]),v._v(" "),_("li",[_("strong",[v._v("绑定死信队列")]),v._v(" ：\n"),_("ul",[_("li",[v._v("在普通队列中配置死信交换器（DLX），当消息在普通队列中过期后，会被转发到死信队列。")])])]),v._v(" "),_("li",[_("strong",[v._v("发送延迟消息")]),v._v(" ：\n"),_("ul",[_("li",[v._v("当用户下单时，将订单信息发送到普通队列，并设置消息的TTL为订单的超时时间（如30分钟）。")])])]),v._v(" "),_("li",[_("strong",[v._v("处理超时订单")]),v._v(" ：\n"),_("ul",[_("li",[v._v("消费者监听死信队列，当消息从普通队列过期并进入死信队列时，消费者会收到该消息，表示订单超时，可以进行取消订单等操作。")])])])]),v._v(" "),_("h3",{attrs:{id:"rocketmq-延时消息"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq-延时消息"}},[v._v("#")]),v._v(" RocketMQ：延时消息")]),v._v(" "),_("p",[v._v("RocketMQ原生支持延迟消息，可以直接设置消息的延迟级别来实现订单超时处理。在RocketMQ5的版本中可以设置任意的延迟时间。")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("// 设置延迟级别，3对应10分钟，4对应30分钟\n        msg.setDelayTimeLevel(4);\n")])])]),_("ul",[_("li",[_("p",[v._v("在RocketMQ 5.x中，发送消息时可以通过 "),_("code",[v._v("setDelayTimeMs")]),v._v("方法设置任意的延迟时间（以毫秒为单位）。")])]),v._v(" "),_("li",[_("p",[v._v("例如，设置延迟30分钟，可以将延迟时间设置为 "),_("code",[v._v("30 * 60 * 1000")]),v._v("毫秒。")]),v._v(" "),_("p",[_("img",{attrs:{src:t(674),alt:"image.png"}})])])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v(' Message message = provider.newMessageBuilder()\n                .setTopic("order_topic")\n                .setBody(body)\n                .setDelayTimeMs(30 * 60 * 1000) // 设置延迟时间（30分钟）\n                .build();\n')])])]),_("h2",{attrs:{id:"在支付系统中-如何利用mq处理支付请求-确保支付的可靠性和事务的一致性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#在支付系统中-如何利用mq处理支付请求-确保支付的可靠性和事务的一致性"}},[v._v("#")]),v._v(" 在支付系统中，如何利用MQ处理支付请求，确保支付的可靠性和事务的一致性")]),v._v(" "),_("p",[_("img",{attrs:{src:t(675),alt:"image.png"}})]),v._v(" "),_("p",[v._v("其他的细讲见代码")]),v._v(" "),_("h2",{attrs:{id:"mq中流量控制的实现-包括限流策略和流量监控-分析源码中相关的实现逻辑"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mq中流量控制的实现-包括限流策略和流量监控-分析源码中相关的实现逻辑"}},[v._v("#")]),v._v(" MQ中流量控制的实现，包括限流策略和流量监控，分析源码中相关的实现逻辑")]),v._v(" "),_("h3",{attrs:{id:"rabbitmq-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-3"}},[v._v("#")]),v._v(" "),_("strong",[v._v("RabbitMQ")])]),v._v(" "),_("p",[v._v("通过设置消费者的预取数量（prefetch count），可以限制消费者从队列中拉取的消息数量，从而控制消费速率。")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v(" @Bean\n    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(ConnectionFactory connectionFactory) {\n        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();\n        factory.setConnectionFactory(connectionFactory);\n        // 设置 prefetchCount，限制消费者每次从队列中拉取的消息数量\n        factory.setPrefetchCount(10); // 每次最多拉取 10 条消息\n        return factory;\n    }\n\n")])])]),_("h3",{attrs:{id:"kafka"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#kafka"}},[v._v("#")]),v._v(" "),_("strong",[v._v("Kafka")])]),v._v(" "),_("h4",{attrs:{id:"生产者"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#生产者"}},[v._v("#")]),v._v(" 生产者")]),v._v(" "),_("p",[v._v("通过配置 "),_("code",[v._v("producer.properties")]),v._v(" 中的 "),_("code",[v._v("max.in.flight.requests.per.connection")]),v._v(" 和 "),_("code",[v._v("linger.ms")]),v._v(" 参数，控制生产者的发送速率。")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("       // 设置 max.in.flight.requests.per.connection\n        props.put(ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION, 1);\n        // 设置 linger.ms\n        props.put(ProducerConfig.LINGER_MS_CONFIG, 100);\n")])])]),_("p",[_("code",[v._v("max.in.flight.requests.per.connection")]),v._v("：**控制每个连接上未确认的请求数量。")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("未确认请求")]),v._v(" ：\n未确认请求是指生产者已经发送给 Broker 但尚未收到确认（acknowledgment）的消息。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("并发性")]),v._v(" ：\n增加该值可以提高生产者的并发性，从而提升吞吐量，因为生产者可以同时发送更多的消息。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("顺序性")]),v._v(" ：\n如果该值大于 1，可能会导致消息乱序。例如：")]),v._v(" "),_("ul",[_("li",[v._v("假设生产者发送了消息 A 和消息 B。")]),v._v(" "),_("li",[v._v("如果消息 A 发送失败并重试，而消息 B 已经成功发送，那么消息 B 可能会先于消息 A 被写入分区，导致消息顺序错乱。")]),v._v(" "),_("li",[v._v("如果需要严格保证消息顺序，建议将该值设置为 "),_("code",[v._v("1")]),v._v("。")])])])]),v._v(" "),_("h4",{attrs:{id:"消费者"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#消费者"}},[v._v("#")]),v._v(" "),_("strong",[v._v("消费者")])]),v._v(" "),_("p",[v._v("使用 Kafka 的 "),_("code",[v._v("fetch.max.bytes")]),v._v(" 和 "),_("code",[v._v("max.poll.records")]),v._v(" 参数控制消费者每次拉取的消息数量。")]),v._v(" "),_("p",[v._v("它们分别用于控制每次拉取的最大字节数和最大消息数。")]),v._v(" "),_("p",[_("code",[v._v("fetch.max.bytes")]),v._v("：该参数限制了消费者每次从 Kafka Broker 拉取数据的最大字节数。它决定了消费者单次请求能够获取的数据量。")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("影响拉取的数据量")]),v._v(" ：\n如果设置的值较小，消费者每次拉取的数据量会减少，从而降低网络带宽的占用，但可能会增加拉取请求的频率。")]),v._v(" "),_("li",[_("strong",[v._v("与分区大小的关系")]),v._v(" ：\n如果单个分区中的数据量超过了 "),_("code",[v._v("fetch.max.bytes")]),v._v("，消费者仍然会拉取整个分区的数据，因此该参数并不能严格限制单次拉取的数据量。")])]),v._v(" "),_("p",[v._v("max.poll.records：控制每次拉取的最大消息数：")]),v._v(" "),_("p",[v._v("该参数限制了消费者每次调用 poll() 方法时返回的最大消息数。")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("影响单次处理的消息量")]),v._v(" ：\n如果设置的值较小，消费者每次处理的消息数量会减少，从而降低单次处理的开销，但可能会增加 "),_("code",[v._v("poll()")]),v._v(" 方法的调用频率。")]),v._v(" "),_("li",[_("strong",[v._v("与消费者处理能力的关系")]),v._v(" ：\n如果消费者的处理能力有限，可以适当减小该值，以避免消息积压。")]),v._v(" "),_("li",[_("strong",[v._v("适用场景")]),v._v(" ：\n"),_("ul",[_("li",[v._v("如果消费者的处理速度较慢，可以减小该值以避免消息堆积。")]),v._v(" "),_("li",[v._v("如果需要减少单次处理的消息量以降低内存占用，也可以调整该值。")])])])]),v._v(" "),_("p",[_("strong",[v._v("综合")])]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("消费者处理能力")]),v._v(" ：\n如果消费者的处理速度较慢，可以适当减小 "),_("code",[v._v("max.poll.records")]),v._v(" 的值，以避免消息堆积。")]),v._v(" "),_("li",[_("strong",[v._v("网络带宽")]),v._v(" ：\n如果网络带宽有限，可以适当减小 "),_("code",[v._v("fetch.max.bytes")]),v._v(" 的值，以减少单次拉取的数据量。")]),v._v(" "),_("li",[_("strong",[v._v("与 "),_("code",[v._v("max.poll.interval.ms")]),v._v(" 的关系")]),v._v(" ：\n"),_("code",[v._v("max.poll.interval.ms")]),v._v(" 参数定义了消费者两次 "),_("code",[v._v("poll()")]),v._v(" 调用之间的最大时间间隔。如果消费者处理消息的时间过长，可能会导致消费者被踢出组（rebalance）。因此，在调整 "),_("code",[v._v("max.poll.records")]),v._v(" 时，也需要考虑 "),_("code",[v._v("max.poll.interval.ms")]),v._v(" 的设置。")])]),v._v(" "),_("h3",{attrs:{id:"rocketmq"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq"}},[v._v("#")]),v._v(" RocketMQ")]),v._v(" "),_("h4",{attrs:{id:"生产者限流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#生产者限流"}},[v._v("#")]),v._v(" "),_("strong",[v._v("生产者限流")])]),v._v(" "),_("p",[_("strong",[v._v("发送速率限制")]),v._v(" ：\n通过设置 "),_("code",[v._v("sendMsgTimeout")]),v._v(" 和 "),_("code",[v._v("maxMessageSize")]),v._v(" 参数，控制生产者的发送速率。")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[_("code",[v._v("sendMsgTimeout")]),v._v("作用")]),v._v(" ：\n该参数用于设置生产者发送消息的超时时间。如果消息在指定时间内未发送成功，生产者会抛出超时异常。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("默认值")]),v._v(" ：\n默认值为 "),_("code",[v._v("3000")]),v._v("（即 3 秒）。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("适用场景")]),v._v(" ：")]),v._v(" "),_("ul",[_("li",[v._v("如果网络延迟较高或 Broker 处理较慢，可以适当增加该值。")]),v._v(" "),_("li",[v._v("如果需要快速失败（fail-fast），可以减小该值。")])])]),v._v(" "),_("li",[_("p",[_("strong",[_("code",[v._v("maxMessageSize：")]),v._v("作用")]),v._v(" ：\n该参数用于设置单条消息的最大大小。如果消息大小超过该值，生产者会抛出异常。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("默认值")]),v._v(" ：\n默认值为 "),_("code",[v._v("4 MB")]),v._v("（即 "),_("code",[v._v("4194304")]),v._v(" 字节）。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("适用场景")]),v._v(" ：")]),v._v(" "),_("ul",[_("li",[v._v("如果需要发送较大的消息，可以适当增加该值。")]),v._v(" "),_("li",[v._v("如果对消息大小有严格限制，可以减小该值。")])])])]),v._v(" "),_("h4",{attrs:{id:"消费者限流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#消费者限流"}},[v._v("#")]),v._v(" "),_("strong",[v._v("消费者限流")])]),v._v(" "),_("p",[_("strong",[v._v("拉取速率限制")]),v._v(" ：\n通过设置 "),_("code",[v._v("pullBatchSize")]),v._v(" 和 "),_("code",[v._v("pullInterval")]),v._v(" 参数，控制消费者的拉取速率。")]),v._v(" "),_("p",[_("code",[v._v("pullBatchSize")])]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("作用")]),v._v(" ：\n该参数用于设置消费者每次从 Broker 拉取的消息数量。")]),v._v(" "),_("li",[_("strong",[v._v("默认值")]),v._v(" ：\n默认值为 "),_("code",[v._v("32")]),v._v("。")]),v._v(" "),_("li",[_("strong",[v._v("适用场景")]),v._v(" ：\n"),_("ul",[_("li",[v._v("如果消费者的处理能力较强，可以适当增加该值以提高吞吐量。")]),v._v(" "),_("li",[v._v("如果消费者的处理能力有限，可以减小该值以避免消息堆积。")])])])]),v._v(" "),_("p",[_("code",[v._v("pullInterval")])]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("作用")]),v._v(" ：\n该参数用于设置消费者两次拉取操作之间的时间间隔（毫秒）。")]),v._v(" "),_("li",[_("strong",[v._v("默认值")]),v._v(" ：\n默认值为 "),_("code",[v._v("0")]),v._v("，表示消费者会立即进行下一次拉取。")]),v._v(" "),_("li",[_("strong",[v._v("适用场景")]),v._v(" ：\n"),_("ul",[_("li",[v._v("如果需要降低消费者的拉取频率，可以适当增加该值。")]),v._v(" "),_("li",[v._v("如果需要实时处理消息，可以减小该值。")])])])]),v._v(" "),_("h2",{attrs:{id:"mq系统如何实现高可用性-如集群模式、主从复制等"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mq系统如何实现高可用性-如集群模式、主从复制等"}},[v._v("#")]),v._v(" MQ系统如何实现高可用性（如集群模式、主从复制等）")]),v._v(" "),_("h3",{attrs:{id:"rabbitmq-4"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-4"}},[v._v("#")]),v._v(" RabbitMQ")]),v._v(" "),_("p",[v._v("RabbitMQ一般是通过镜像队列来实现高可用。（RabbitMQ的集群功能不行，消息本身不会在集群节点之间复制，如果某个节点故障，其上的队列和消息将不可用）")]),v._v(" "),_("p",[v._v("镜像队列实现方式")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("主从复制")]),v._v(" ：\n每个队列可以配置多个镜像（副本），分布在不同的节点上。主节点负责处理消息，从节点同步主节点的数据。")]),v._v(" "),_("li",[_("strong",[v._v("自动故障转移")]),v._v(" ：\n如果主节点故障，RabbitMQ 会自动选举一个从节点作为新的主节点。")])]),v._v(" "),_("h3",{attrs:{id:"rocketmq-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq-2"}},[v._v("#")]),v._v(" RocketMQ")]),v._v(" "),_("h4",{attrs:{id:"_2-1-主从复制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-主从复制"}},[v._v("#")]),v._v(" 2.1 主从复制")]),v._v(" "),_("p",[v._v("RocketMQ 通过 "),_("strong",[v._v("主从复制")]),v._v(" 实现高可用性。")]),v._v(" "),_("h5",{attrs:{id:"实现方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实现方式"}},[v._v("#")]),v._v(" 实现方式")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("Broker 主从架构")]),v._v(" ：\n每个 Broker 组包含一个主节点（Master）和多个从节点（Slave）。主节点负责处理读写请求，从节点同步主节点的数据。")]),v._v(" "),_("li",[_("strong",[v._v("消息同步")]),v._v(" ：\n主节点将消息同步到从节点，确保从节点上有完整的数据副本。")]),v._v(" "),_("li",[_("strong",[v._v("故障转移")]),v._v(" ：\n如果主节点故障，RocketMQ 会自动切换到从节点继续提供服务。")])]),v._v(" "),_("h5",{attrs:{id:"配置步骤"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#配置步骤"}},[v._v("#")]),v._v(" 配置步骤")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("部署多个 Broker 组，每个组包含一个主节点和多个从节点。")])]),v._v(" "),_("li",[_("p",[v._v("在配置文件中指定主从关系：\nproperties")]),v._v(" "),_("p",[v._v("复制")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("brokerClusterName=DefaultCluster\nbrokerName=broker-a\nbrokerId=0 # 0 表示主节点，大于 0 表示从节点\n")])])])]),v._v(" "),_("li",[_("p",[v._v("客户端配置 NameServer 地址，NameServer 会管理 Broker 的主从关系。")])])]),v._v(" "),_("h5",{attrs:{id:"优点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[v._v("#")]),v._v(" 优点")]),v._v(" "),_("ul",[_("li",[v._v("提高消息的可用性和可靠性。")]),v._v(" "),_("li",[v._v("自动故障转移，保证服务连续性。")])]),v._v(" "),_("h5",{attrs:{id:"缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[v._v("#")]),v._v(" 缺点")]),v._v(" "),_("ul",[_("li",[v._v("从节点只提供读服务，写操作仍然依赖主节点。")])]),v._v(" "),_("hr"),v._v(" "),_("h4",{attrs:{id:"_2-2-dledger-模式-raft-协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-dledger-模式-raft-协议"}},[v._v("#")]),v._v(" 2.2 DLedger 模式（Raft 协议）")]),v._v(" "),_("p",[v._v("RocketMQ 4.5 及以上版本支持  "),_("strong",[v._v("DLedger 模式")]),v._v(" ，基于 Raft 协议实现高可用性。")]),v._v(" "),_("h5",{attrs:{id:"实现方式-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实现方式-2"}},[v._v("#")]),v._v(" 实现方式")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("多副本一致性")]),v._v(" ：\n使用 Raft 协议保证多个副本之间的一致性。")]),v._v(" "),_("li",[_("strong",[v._v("自动选举")]),v._v(" ：\n如果主节点故障，DLedger 会自动选举新的主节点。")])]),v._v(" "),_("h5",{attrs:{id:"配置步骤-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#配置步骤-2"}},[v._v("#")]),v._v(" 配置步骤")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("在 Broker 配置文件中启用 DLedger：\nproperties")]),v._v(" "),_("p",[v._v("复制")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("enableDLegerCommitLog=true\ndLegerGroup=broker-a\ndLegerPeers=n0-127.0.0.1:40911;n1-127.0.0.1:40912;n2-127.0.0.1:40913\n")])])])]),v._v(" "),_("li",[_("p",[v._v("启动多个 Broker 节点，每个节点运行一个 DLedger 实例。")])])]),v._v(" "),_("h5",{attrs:{id:"优点-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优点-2"}},[v._v("#")]),v._v(" 优点")]),v._v(" "),_("ul",[_("li",[v._v("强一致性，保证数据不丢失。")]),v._v(" "),_("li",[v._v("自动故障转移，提高系统可用性。")])]),v._v(" "),_("h5",{attrs:{id:"缺点-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缺点-2"}},[v._v("#")]),v._v(" 缺点")]),v._v(" "),_("ul",[_("li",[v._v("增加了系统复杂性和性能开销。")])]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"_3-kafka"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-kafka"}},[v._v("#")]),v._v(" 3. Kafka")]),v._v(" "),_("h4",{attrs:{id:"_3-1-分区副本机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-分区副本机制"}},[v._v("#")]),v._v(" 3.1 分区副本机制")]),v._v(" "),_("p",[v._v("Kafka 通过 "),_("strong",[v._v("分区副本")]),v._v(" 机制实现高可用性。")]),v._v(" "),_("h5",{attrs:{id:"实现方式-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实现方式-3"}},[v._v("#")]),v._v(" 实现方式")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("分区和副本")]),v._v(" ：\n每个主题（Topic）分为多个分区（Partition），每个分区可以有多个副本（Replica），分布在不同的 Broker 上。")]),v._v(" "),_("li",[_("strong",[v._v("主从复制")]),v._v(" ：\n每个分区有一个主副本（Leader）和多个从副本（Follower）。主副本负责处理读写请求，从副本同步主副本的数据。")]),v._v(" "),_("li",[_("strong",[v._v("故障转移")]),v._v(" ：\n如果主副本故障，Kafka 会从从副本中选举一个新的主副本。")])]),v._v(" "),_("h5",{attrs:{id:"配置步骤-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#配置步骤-3"}},[v._v("#")]),v._v(" 配置步骤")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("创建主题时指定分区和副本数：\nbash")]),v._v(" "),_("p",[v._v("复制")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("kafka-topics.sh --create --topic my-topic --partitions 3 --replication-factor 2 --bootstrap-server localhost:9092\n")])])]),_("ul",[_("li",[_("code",[v._v("partitions")]),v._v("：分区数。")]),v._v(" "),_("li",[_("code",[v._v("replication-factor")]),v._v("：副本数。")])])]),v._v(" "),_("li",[_("p",[v._v("Kafka 会自动管理分区副本的分布和主从关系。")])])]),v._v(" "),_("h5",{attrs:{id:"优点-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优点-3"}},[v._v("#")]),v._v(" 优点")]),v._v(" "),_("ul",[_("li",[v._v("提高消息的可用性和可靠性。")]),v._v(" "),_("li",[v._v("自动故障转移，保证服务连续性。")])]),v._v(" "),_("h5",{attrs:{id:"缺点-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缺点-3"}},[v._v("#")]),v._v(" 缺点")]),v._v(" "),_("ul",[_("li",[v._v("副本数增加会占用更多的存储和网络带宽。")])]),v._v(" "),_("hr"),v._v(" "),_("h4",{attrs:{id:"_3-2-isr-机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-isr-机制"}},[v._v("#")]),v._v(" 3.2 ISR 机制")]),v._v(" "),_("p",[v._v("Kafka 使用 "),_("strong",[v._v("ISR（In-Sync Replicas）")]),v._v(" 机制来保证数据的一致性。")]),v._v(" "),_("h5",{attrs:{id:"实现方式-4"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实现方式-4"}},[v._v("#")]),v._v(" 实现方式")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("ISR 集合")]),v._v(" ：\nISR 集合包含所有与主副本保持同步的从副本。")]),v._v(" "),_("li",[_("strong",[v._v("消息确认")]),v._v(" ：\n生产者可以配置 "),_("code",[v._v("acks")]),v._v(" 参数来控制消息的确认方式：\n"),_("ul",[_("li",[_("code",[v._v("acks=0")]),v._v("：不等待确认。")]),v._v(" "),_("li",[_("code",[v._v("acks=1")]),v._v("：等待主副本确认。")]),v._v(" "),_("li",[_("code",[v._v("acks=all")]),v._v("：等待所有 ISR 副本确认。")])])])]),v._v(" "),_("h5",{attrs:{id:"优点-4"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优点-4"}},[v._v("#")]),v._v(" 优点")]),v._v(" "),_("ul",[_("li",[v._v("灵活的消息确认机制，平衡性能和可靠性。")]),v._v(" "),_("li",[v._v("保证数据的一致性。")])]),v._v(" "),_("h5",{attrs:{id:"缺点-4"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缺点-4"}},[v._v("#")]),v._v(" 缺点")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("acks=all")]),v._v(" 会增加消息的延迟。")])])])}),[],!1,null,null,null);_.default=r.exports}}]);