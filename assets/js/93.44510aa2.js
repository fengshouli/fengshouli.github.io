(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{672:function(a,t,v){"use strict";v.r(t);var _=v(17),s=Object(_.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"manacher算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#manacher算法"}},[a._v("#")]),a._v(" Manacher算法")]),a._v(" "),t("h2",{attrs:{id:"跟kmp一样-每年大厂必考的一道题-又频繁又噩梦"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#跟kmp一样-每年大厂必考的一道题-又频繁又噩梦"}},[a._v("#")]),a._v(" 跟kmp一样,每年大厂必考的一道题.又频繁又噩梦.")]),a._v(" "),t("p",[a._v("manacher是一个加速回文的算法,暴力回文算法复杂度是O(N^2),manacher可以做到O(N).神奇")]),a._v(" "),t("p",[a._v("最长回文子串,子串,一定是连续的.")]),a._v(" "),t("h2",{attrs:{id:"暴力算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#暴力算法"}},[a._v("#")]),a._v(" 暴力算法")]),a._v(" "),t("p",[a._v("我们遍历字符串每个位置,然后i-1判断是否等于i+1位置,如果等,那就i-2是否等于i+2,一直下去,记录每个i位置最大的回文子串长度.")]),a._v(" "),t("p",[a._v("但是我们发现,有个问题,偶数的时候,我们找不到,是在虚轴上的时候,才能找到,但是我们不会遍历到这个虚轴,怎么办.")]),a._v(" "),t("p",[a._v("我们给他加工下,每个字符中间用#包起来,例如12321变成#1#2#3#2#1#,这样,不管是真实字符,还是虚轴,我们都会遍历到.那么这个字符一定要用#吗?还是任意都行?我们观察下会发现,真实字符,只会和真实字符比,#只会和#比,所以,是什么都行.")]),a._v(" "),t("h2",{attrs:{id:"manacher算法核心"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#manacher算法核心"}},[a._v("#")]),a._v(" Manacher算法核心")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("理解回文直径和回文半径,就是指 i位置,每个位置的回文直径,半径")]),a._v(" "),t("p",[a._v("例如,abc12321def ,对于3来说,直径就是5,半径是3.当然了,经过我们#的处理,任何串都是奇数,例如1221,#1#2#2#1#,")])]),a._v(" "),t("li",[t("p",[a._v("记录一个回文半径数组,par[],")])]),a._v(" "),t("li",[t("p",[a._v("理解所有中心的回文最右边界R，和取得R时的中心点C")]),a._v(" "),t("p",[a._v("举个例子,就是说一个串,任何位置,只要回文串最右边界推得更往右了,就用R抓住这个位置,同时R变的时候,记录C,C是哪个位置让他推出去的,两个变量是伴生的,当然了这个操作是基于那个加工串做的,就是###那个,R一开始就是在-1位置.")])]),a._v(" "),t("li",[t("p",[a._v("理解   L…(i`)…C…(i)…R  的结构，以及根据i’回文长度进行的状况划分,每一种情况划分，都可以加速求解i回文半径的过程")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("i没被R罩住,这种没优化")]),a._v(" "),t("ol",[t("li",[a._v("例如R在-1时候,我搞到0位置,不进行任何优化,因为我还没看过,就暴力扩.")])])]),a._v(" "),t("li",[t("p",[a._v("i被R罩住了,这种有优化,具体分为三种情况")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("i'扩的范围,彻底在LR,范围内,")]),a._v(" "),t("p",[a._v("例如:注意这个是带#的但是我没写,太乱了")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("ab[cdc]ks t skcdcda\nL   i'    C    i  R\n")])])]),t("p",[a._v("看上面这个,i'的范围,完全在LR范围内.这种情况,我不用扩了,i位置跟i'一模一样.")])]),a._v(" "),t("li",[t("p",[a._v("i'的范围,在LR范围之外")]),a._v(" "),t("p",[a._v("举个例子:")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("(ab [ cdedc ba)t s tabcdedc ] f\n    L   i'L'     C    R'i   R    \n    {  甲  }          {  乙  }\n")])])]),t("p",[a._v("看上面这个,i'位置,超过L了,")]),a._v(" "),t("p",[a._v("首先证明,L~L'肯定是回文,因为他们是i'对称.")]),a._v(" "),t("p",[a._v("然后,R'~R也肯定是回文,因为他们和甲相对C是回文.")]),a._v(" "),t("p",[a._v("那甲左右,假设是ab,乙左右是xy,因为i'的范围超过L,那说明a==b,因为相对C回文,所以,b == x,")]),a._v(" "),t("p",[a._v("那么为什么LR范围不包含a和y,因为a和y一定不相等,也就是a == x 但是 a ≠ y 所以 x ≠ y,")]),a._v(" "),t("p",[a._v("也就是说,i位置的范围,仅仅是R'~R,不可能更大了")])]),a._v(" "),t("li",[t("p",[a._v("i'的左范围,正好压中了L,")]),a._v(" "),t("p",[a._v("举个例子")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("  x a b c b a s t s a b c b a s\n    (   i'  )\t\t\t\t{\t\t\t\t}\n    L       L'  C   R'  i   R\n")])])]),t("p",[a._v("看上面这个,我们知道i位置,至少是R'~R我是不用验证的,但是有没有可能突破了,不知道,得去验证,例如上面这个,就可以突破到s")])])])])])])]),a._v(" "),t("h2",{attrs:{id:"代码解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码解析"}},[a._v("#")]),a._v(" 代码解析")])])}),[],!1,null,null,null);t.default=s.exports}}]);